# 控制机制
1. 竞态条件
2. 临界区  
    1. 信号量
# 内核锁机制
1. 原子操作  
    1. 对整数的原子操作：在汇编语言中，加1操作通常分为3步执行：  
        1. 将计数器值从内存复制到处理器寄存器
        2. 将其值加1
        3. 将寄存器数据回写到内存
2. 自旋锁：  
    在内核等待自旋释放时，会重复检查是否能获取到锁，而不会进入睡眠状态（忙等待）
3. 信号量
4. 读/写锁

5. RCU机制
read-copy-update，适用场景：
    1. 对共享资源的访问大部分时间应该是只读的，写访问应该相对较少
    2. 在RCU保护的代码范围内，内核不能进入是睡眠状态
    3. 受保护资源必须通过指针访问  
原理：该机制记录了指向共享数据结构的指针的所有使用者。在该结构将要改变时，首先创建一个副本，在副本中修改。在所有进行读访问的使用者结束对就副本的读取之后，指针可以替换为指向新的、修改后副本的指针。这种机制运行写并发进行。
缺点：不对写操作之间的干扰提供保护。

7. 互斥量  
    1. 经典互斥量（基于信号量的实现）：
    ```
    struct mutex {
        /*1: 未锁定，0：锁定，负值：锁定，可能有等待者*/
        atomic_t count;
        spinlock_t wait_lock;
        struct list_head wait_list;
    }
    ```   
    2. 实时互斥量：需要在编译内核时，通过配置CONFIG_RT_MUTEX显式启用。与普通的互斥量相比，实时互斥量实现了：优先级继承，该特性可用于解决优先级反转的影响。
    ```
    struct rt_mutex {
        spinlock_t wait_lock;
        struct plist_head wait_list;
        struct task_struct *owner;
    }
    ```
    所有等待的进程都在wait_list中排队。与普通互斥量相比，决定性的改变时等待列表中的进程按优先级排序。

8. 信号  
    1. 通过kill命令根据pid向进程发送信号
    2. 进程必须设置信号处理程序来处理信号。这些处理程序在信号发送到进程时调用。但有几个信号的行为无法修改：如SIGKILL。如果没有显式设置处理程序，内核则使用默认的处理程序
    3. 信号特性：  
        1. 进程可以决定阻塞特定的信号，即信号屏蔽。在信号被阻塞时，内核将其放置到待决列表上。如果同一个信号被阻塞多次，则在待决列表中只放置一次。不管发送了多少相同的信号，在进程删除阻塞之后，都只会接收到一个信号。
        2. SIGKILL信号无法阻塞，也不能通过特定于进程的处理程序处理。之所以不能修改该信号的行为，是因为他是从系统删除失控进程的最后手段。
        3. init进程属于特例。内核会忽略发送给该进程的SIGKILL信号。
        4. 尽管信号处理发生在内核中，但设置的信号处理程序是在用户态运行的。
        5. 通常信号处理程序使用所属进程在用户状态下的栈。但POSIX强制要求提供一种选项，在专门用于信号处理的栈上运行信号处理程序，这个附加的栈，必须通过用户应用程序显式分配，其地址和长度分别保存在sas_ss_sp和sas_ss_size。
        6. 系统调用不会触发信号队里的处理。在每次由核心态切换到用户态时，内核都会发起信号队列处理。

