<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">

<!-- BEGINFRONTTAG: The following is front matter for the parent book -->
<!--  <bookinfo> -->
<!--   <title>SCSI Subsystem Interfaces</title> -->
<!--    -->
<!--   <authorgroup> -->
<!--    <author> -->
<!--     <firstname>Douglas</firstname> -->
<!--     <surname>Gilbert</surname> -->
<!--     <affiliation> -->
<!--      <address> -->
<!--       <email>dgilbert@interlog.com</email> -->
<!--      </address> -->
<!--     </affiliation> -->
<!--    </author> -->
<!--   </authorgroup> -->
<!--   <pubdate>2003-08-11</pubdate> -->
<!--  -->
<!--   <copyright> -->
<!--    <year>2002</year> -->
<!--    <year>2003</year> -->
<!--    <holder>Douglas Gilbert</holder> -->
<!--   </copyright> -->
<!--  -->
<!--   <legalnotice> -->
<!--    <para> -->
<!--      This documentation is free software; you can redistribute -->
<!--      it and/or modify it under the terms of the GNU General Public -->
<!--      License as published by the Free Software Foundation; either -->
<!--      version 2 of the License, or (at your option) any later -->
<!--      version. -->
<!--    </para> -->
<!--        -->
<!--    <para> -->
<!--      This program is distributed in the hope that it will be -->
<!--      useful, but WITHOUT ANY WARRANTY; without even the implied -->
<!--      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. -->
<!--      See the GNU General Public License for more details. -->
<!--    </para> -->
<!--        -->
<!--    <para> -->
<!--      You should have received a copy of the GNU General Public -->
<!--      License along with this program; if not, write to the Free -->
<!--      Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, -->
<!--      MA 02111-1307 USA -->
<!--    </para> -->
<!--        -->
<!--    <para> -->
<!--      For more details see the file COPYING in the source -->
<!--      distribution of Linux. -->
<!--    </para> -->
<!--   </legalnotice> -->
<!--  -->
<!--  </bookinfo> -->

<!-- ENDFRONTTAG: End front matter -->

<refentry>
<refmeta>

<refentrytitle><phrase id="API-queuecommand">queuecommand</phrase></refentrytitle>
<manvolnum>9</manvolnum>
</refmeta>
<refnamediv>
 <refname>queuecommand</refname>
 <refpurpose>
      queue scsi command, invoke 'done' on completion
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>queuecommand </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>scp</parameter></paramdef>
   <paramdef>void (*<parameter>done</parameter>)
     <funcparams>struct scsi_cmnd *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>scp</parameter></term>
   <listitem>
    <para>
      pointer to scsi command object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>done</parameter></term>
   <listitem>
    <para>
      function pointer to be invoked on completion
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns 0 on success.
   </para><para>

   If there's a failure, return either:
   </para><para>

   SCSI_MLQUEUE_DEVICE_BUSY if the device queue is full, or
   SCSI_MLQUEUE_HOST_BUSY if the entire host queue is full
   </para><para>

   On both of these returns, the mid-layer will requeue the I/O
   </para><para>

   - if the return is SCSI_MLQUEUE_DEVICE_BUSY, only that particular
   device will be paused, and it will be unpaused when a command to
   the device returns (or after a brief delay if there are no more
   outstanding commands to it).  Commands to other devices continue
   to be processed normally.
   </para><para>

   - if the return is SCSI_MLQUEUE_HOST_BUSY, all I/O to the host
   is paused and will be unpaused when any command returns from
   the host (or after a brief delay if there are no outstanding
   commands to the host).
   </para><para>

   For compatibility with earlier versions of queuecommand, any
   other return value is treated the same as
   SCSI_MLQUEUE_HOST_BUSY.
   </para><para>

   Other types of errors that are detected immediately may be
   flagged by setting scp-&gt;result to an appropriate value,
   invoking the 'done' callback, and then returning 0 from this
   function. If the command is not performed immediately (and the
   LLD is starting (or will start) the given command) then this
   function should place 0 in scp-&gt;result and return 0.
   </para><para>

   Command ownership.  If the driver returns zero, it owns the
   command and must take responsibility for ensuring the 'done'
   callback is executed.  Note: the driver may call done before
   returning zero, but after it has called done, it may not
   return any value other than zero.  If the driver makes a
   non-zero return, it must not execute the command's done
   callback at any time.
 </para>
</refsect1>
<refsect1>
 <title>Locks</title>
 <para>
    struct Scsi_Host::host_lock held on entry (with <quote>irqsave</quote>)
   and is expected to be held on return.
 </para>
</refsect1>
<refsect1>
 <title>Calling context</title>
 <para>
    in interrupt (soft irq) or process context
 </para>
</refsect1>
<refsect1>
 <title>Notes</title>
 <para>
    This function should be relatively fast. Normally it will
   not wait for IO to complete. Hence the 'done' callback is invoked 
   (often directly from an interrupt service routine) some time after
   this function has returned. In some cases (e.g. pseudo adapter 
   drivers that manufacture the response to a SCSI INQUIRY)
   the 'done' callback may be invoked before this function returns.
   If the 'done' callback is not invoked within a certain period
   the SCSI mid level will commence error processing.
   If a status of CHECK CONDITION is placed in <quote>result</quote> when the
   'done' callback is invoked, then the LLD driver should 
 </para>
</refsect1>
<refsect1>
 <title>perform autosense and fill in the struct scsi_cmnd</title>
 <para>
   :sense_buffer
   array. The scsi_cmnd::sense_buffer array is zeroed prior to
   the mid level queuing a command to an LLD.
 </para>
</refsect1>
<refsect1>
 <title>Defined in</title>
 <para>
    LLD
 </para>
</refsect1>
<refsect1><title>About this document</title>
<para>
This documentation was generated with kernel version 2.6.11.
</para>
</refsect1>
</refentry>
