<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN"[]>
<book id="LinuxKernelAPI">
 <bookinfo>
  <title>The Linux Kernel API</title>
  
  <legalnotice>
   <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
      
   <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
      
   <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
      
   <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
  </legalnotice>
 </bookinfo>

<toc></toc>

  <chapter id="Basics">
     <title>Driver Basics</title>
     <sect1><title>Driver Entry and Exit points</title>
<!-- include/linux/init.h -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-module-init">module_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>module_init</refname>
 <refpurpose>
   driver initialization entry point
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>module_init </function></funcdef>
   <paramdef> <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
      function to be run at kernel boot time or module insertion
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>module_init</function> will either be called during do_initcalls (if
   builtin) or at module insertion time (if a module).  There can only
   be one per module.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-module-exit">module_exit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>module_exit</refname>
 <refpurpose>
      driver exit entry point
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>module_exit </function></funcdef>
   <paramdef> <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
      function to be run when driver is removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>module_exit</function> will wrap the driver clean-up code
   with <function>cleanup_module</function> when used with rmmod when
   the driver is a module.  If the driver is statically
   compiled into the kernel, <function>module_exit</function> has no effect.
   There can only be one per module.
 </para>
</refsect1>
</refentry>

     </sect1>

     <sect1><title>Atomic and pointer manipulation</title>
<!-- include/asm-i386/atomic.h -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-atomic-read">atomic_read</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>atomic_read</refname>
 <refpurpose>
   read atomic variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>atomic_read </function></funcdef>
   <paramdef> <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
      pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Atomically reads the value of <parameter>v</parameter>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-atomic-set">atomic_set</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>atomic_set</refname>
 <refpurpose>
      set atomic variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>atomic_set </function></funcdef>
   <paramdef> <parameter>v</parameter></paramdef>
   <paramdef> <parameter>i</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
      pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
      required value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Atomically sets the value of <parameter>v</parameter> to <parameter>i</parameter>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-atomic-add">atomic_add</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>atomic_add</refname>
 <refpurpose>
      add integer to atomic variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>atomic_add </function></funcdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
      integer value to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
      pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Atomically adds <parameter>i</parameter> to <parameter>v</parameter>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-atomic-sub">atomic_sub</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>atomic_sub</refname>
 <refpurpose>
      subtract the atomic variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>atomic_sub </function></funcdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
      integer value to subtract
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
      pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Atomically subtracts <parameter>i</parameter> from <parameter>v</parameter>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-atomic-sub-and-test">atomic_sub_and_test</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>atomic_sub_and_test</refname>
 <refpurpose>
      subtract value from variable and test result
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atomic_sub_and_test </function></funcdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
      integer value to subtract
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
      pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Atomically subtracts <parameter>i</parameter> from <parameter>v</parameter> and returns
   true if the result is zero, or false for all
   other cases.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-atomic-inc">atomic_inc</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>atomic_inc</refname>
 <refpurpose>
      increment atomic variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>atomic_inc </function></funcdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
      pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Atomically increments <parameter>v</parameter> by 1.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-atomic-dec">atomic_dec</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>atomic_dec</refname>
 <refpurpose>
      decrement atomic variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>atomic_dec </function></funcdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
      pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Atomically decrements <parameter>v</parameter> by 1.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-atomic-dec-and-test">atomic_dec_and_test</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>atomic_dec_and_test</refname>
 <refpurpose>
      decrement and test
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atomic_dec_and_test </function></funcdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
      pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Atomically decrements <parameter>v</parameter> by 1 and
   returns true if the result is 0, or false for all other
   cases.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-atomic-inc-and-test">atomic_inc_and_test</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>atomic_inc_and_test</refname>
 <refpurpose>
      increment and test 
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atomic_inc_and_test </function></funcdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
      pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Atomically increments <parameter>v</parameter> by 1
   and returns true if the result is zero, or false for all
   other cases.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-atomic-add-negative">atomic_add_negative</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>atomic_add_negative</refname>
 <refpurpose>
      add and test if negative
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atomic_add_negative </function></funcdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
      integer value to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
      pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Atomically adds <parameter>i</parameter> to <parameter>v</parameter> and returns true
   if the result is negative, or false when
   result is greater than or equal to zero.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-atomic-add-return">atomic_add_return</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>atomic_add_return</refname>
 <refpurpose>
      add and return
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atomic_add_return </function></funcdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
      integer value to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
      pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Atomically adds <parameter>i</parameter> to <parameter>v</parameter> and returns <parameter>i</parameter> + <parameter>v</parameter>
 </para>
</refsect1>
</refentry>

<!-- include/asm-i386/unaligned.h -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-get-unaligned">get_unaligned</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>get_unaligned</refname>
 <refpurpose>
   get value from possibly mis-aligned location
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>get_unaligned </function></funcdef>
   <paramdef> <parameter>ptr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
      pointer to value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This macro should be used for accessing values larger in size than 
   single bytes at locations that are expected to be improperly aligned, 
   e.g. retrieving a u16 value from a location not u16-aligned.
   </para><para>

   Note that unaligned accesses can be very expensive on some architectures.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-put-unaligned">put_unaligned</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>put_unaligned</refname>
 <refpurpose>
      put value to a possibly mis-aligned location
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>put_unaligned </function></funcdef>
   <paramdef> <parameter>val</parameter></paramdef>
   <paramdef> <parameter>ptr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
      value to place
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
      pointer to location
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This macro should be used for placing values larger in size than 
   single bytes at locations that are expected to be improperly aligned, 
   e.g. writing a u16 value to a location not u16-aligned.
   </para><para>

   Note that unaligned accesses can be very expensive on some architectures.
 </para>
</refsect1>
</refentry>

     </sect1>

<!-- FIXME:
  kernel/sched.c has no docs, which stuffs up the sgml.  Comment
  out until somebody adds docs.  KAO
     <sect1><title>Delaying, scheduling, and timer routines</title>
X!Ekernel/sched.c
     </sect1>
KAO -->
  </chapter>

  <chapter id="adt">
     <title>Data Types</title>
     <sect1><title>Doubly Linked Lists</title>
<!-- include/linux/list.h -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-add">list_add</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_add</refname>
 <refpurpose>
   add a new entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>list_add </function></funcdef>
   <paramdef>struct list_head * <parameter>new</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>new</parameter></term>
   <listitem>
    <para>
      new entry to be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      list head to add it after
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Insert a new entry after the specified head.
   This is good for implementing stacks.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-add-tail">list_add_tail</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_add_tail</refname>
 <refpurpose>
      add a new entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>list_add_tail </function></funcdef>
   <paramdef>struct list_head * <parameter>new</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>new</parameter></term>
   <listitem>
    <para>
      new entry to be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      list head to add it before
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Insert a new entry before the specified head.
   This is useful for implementing queues.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-add-rcu">list_add_rcu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_add_rcu</refname>
 <refpurpose>
      add a new entry to rcu-protected list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>list_add_rcu </function></funcdef>
   <paramdef>struct list_head * <parameter>new</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>new</parameter></term>
   <listitem>
    <para>
      new entry to be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      list head to add it after
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Insert a new entry after the specified head.
   This is good for implementing stacks.
   </para><para>

   The caller must take whatever precautions are necessary
   (such as holding appropriate locks) to avoid racing
   with another list-mutation primitive, such as <function>list_add_rcu</function>
   or <function>list_del_rcu</function>, running on this same list.
   However, it is perfectly legal to run concurrently with
   the _rcu list-traversal primitives, such as
   <function>list_for_each_entry_rcu</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-add-tail-rcu">list_add_tail_rcu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_add_tail_rcu</refname>
 <refpurpose>
      add a new entry to rcu-protected list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>list_add_tail_rcu </function></funcdef>
   <paramdef>struct list_head * <parameter>new</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>new</parameter></term>
   <listitem>
    <para>
      new entry to be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      list head to add it before
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Insert a new entry before the specified head.
   This is useful for implementing queues.
   </para><para>

   The caller must take whatever precautions are necessary
   (such as holding appropriate locks) to avoid racing
   with another list-mutation primitive, such as <function>list_add_tail_rcu</function>
   or <function>list_del_rcu</function>, running on this same list.
   However, it is perfectly legal to run concurrently with
   the _rcu list-traversal primitives, such as
   <function>list_for_each_entry_rcu</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-del">list_del</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_del</refname>
 <refpurpose>
      deletes entry from list.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>list_del </function></funcdef>
   <paramdef>struct list_head * <parameter>entry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
      the element to delete from the list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Note</title>
 <para>
    list_empty on entry does not return true after this, the entry is
   in an undefined state.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-del-rcu">list_del_rcu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_del_rcu</refname>
 <refpurpose>
      deletes entry from list without re-initialization
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>list_del_rcu </function></funcdef>
   <paramdef>struct list_head * <parameter>entry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
      the element to delete from the list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Note</title>
 <para>
    list_empty on entry does not return true after this,
   the entry is in an undefined state. It is useful for RCU based
   lockfree traversal.
   </para><para>

   In particular, it means that we can not poison the forward
   pointers that may still be used for walking the list.
   </para><para>

   The caller must take whatever precautions are necessary
   (such as holding appropriate locks) to avoid racing
   with another list-mutation primitive, such as <function>list_del_rcu</function>
   or <function>list_add_rcu</function>, running on this same list.
   However, it is perfectly legal to run concurrently with
   the _rcu list-traversal primitives, such as
   <function>list_for_each_entry_rcu</function>.
   </para><para>

   Note that the caller is not permitted to immediately free
   the newly deleted entry.  Instead, either <function>synchronize_kernel</function>
   or <function>call_rcu</function> must be used to defer freeing until an RCU
   grace period has elapsed.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-del-init">list_del_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_del_init</refname>
 <refpurpose>
      deletes entry from list and reinitialize it.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>list_del_init </function></funcdef>
   <paramdef>struct list_head * <parameter>entry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
      the element to delete from the list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-move">list_move</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_move</refname>
 <refpurpose>
      delete from one list and add as another's head
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>list_move </function></funcdef>
   <paramdef>struct list_head * <parameter>list</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      the entry to move
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      the head that will precede our entry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-move-tail">list_move_tail</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_move_tail</refname>
 <refpurpose>
      delete from one list and add as another's tail
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>list_move_tail </function></funcdef>
   <paramdef>struct list_head * <parameter>list</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      the entry to move
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      the head that will follow our entry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-empty">list_empty</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_empty</refname>
 <refpurpose>
      tests whether a list is empty
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>list_empty </function></funcdef>
   <paramdef>const struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      the list to test.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-empty-careful">list_empty_careful</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_empty_careful</refname>
 <refpurpose>
      tests whether a list is
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>list_empty_careful </function></funcdef>
   <paramdef>const struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      the list to test.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   empty _and_ checks that no other CPU might be
   in the process of still modifying either member
 </para>
</refsect1>
<refsect1>
 <title>NOTE</title>
 <para>
    using <function>list_empty_careful</function> without synchronization
   can only be safe if the only activity that can happen
   to the list entry is <function>list_del_init</function>. Eg. it cannot be used
   if another CPU could re-<function>list_add</function> it.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-splice">list_splice</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_splice</refname>
 <refpurpose>
      join two lists
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>list_splice </function></funcdef>
   <paramdef>struct list_head * <parameter>list</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      the new list to add.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      the place to add it in the first list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-splice-init">list_splice_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_splice_init</refname>
 <refpurpose>
      join two lists and reinitialise the emptied list.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>list_splice_init </function></funcdef>
   <paramdef>struct list_head * <parameter>list</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      the new list to add.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      the place to add it in the first list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The list at <parameter>list</parameter> is reinitialised
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-entry">list_entry</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_entry</refname>
 <refpurpose>
      get the struct for this entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_entry </function></funcdef>
   <paramdef> <parameter>ptr</parameter></paramdef>
   <paramdef> <parameter>type</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
     	the &amp;struct list_head pointer.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     	the type of the struct this is embedded in.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     	the name of the list_struct within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-for-each">list_for_each</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_for_each</refname>
 <refpurpose>
     	iterate over a list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_for_each </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the &amp;struct list_head to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---list-for-each">__list_for_each</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__list_for_each</refname>
 <refpurpose>
     	iterate over a list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>__list_for_each </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the &amp;struct list_head to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This variant differs from <function>list_for_each</function> in that it's the
   simplest possible list iteration code, no prefetching is done.
   Use this for code that knows the list to be very short (empty
   or 1 entry) most of the time.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-for-each-prev">list_for_each_prev</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_for_each_prev</refname>
 <refpurpose>
     	iterate over a list backwards
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_for_each_prev </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the &amp;struct list_head to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-for-each-safe">list_for_each_safe</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_for_each_safe</refname>
 <refpurpose>
     	iterate over a list safe against removal of list entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_for_each_safe </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>n</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the &amp;struct list_head to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     		another &amp;struct list_head to use as temporary storage
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-for-each-entry">list_for_each_entry</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_for_each_entry</refname>
 <refpurpose>
     	iterate over list of given type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_for_each_entry </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the type * to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     	the name of the list_struct within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-for-each-entry-reverse">list_for_each_entry_reverse</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_for_each_entry_reverse</refname>
 <refpurpose>
      iterate backwards over list of given type.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_for_each_entry_reverse </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the type * to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     	the name of the list_struct within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-prepare-entry">list_prepare_entry</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_prepare_entry</refname>
 <refpurpose>
      prepare a pos entry for use as a start point in
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_prepare_entry </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the type * to use as a start point
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head of the list
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     	the name of the list_struct within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   list_for_each_entry_continue
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-for-each-entry-continue">list_for_each_entry_continue</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_for_each_entry_continue</refname>
 <refpurpose>
     	iterate over list of given type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_for_each_entry_continue </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the type * to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     	the name of the list_struct within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   continuing after existing point
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-for-each-entry-safe">list_for_each_entry_safe</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_for_each_entry_safe</refname>
 <refpurpose>
      iterate over list of given type safe against removal of list entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_for_each_entry_safe </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>n</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the type * to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     		another type * to use as temporary storage
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     	the name of the list_struct within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-for-each-rcu">list_for_each_rcu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_for_each_rcu</refname>
 <refpurpose>
     	iterate over an rcu-protected list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_for_each_rcu </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the &amp;struct list_head to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This list-traversal primitive may safely run concurrently with
   the _rcu list-mutation primitives such as <function>list_add_rcu</function>
   as long as the traversal is guarded by <function>rcu_read_lock</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-for-each-safe-rcu">list_for_each_safe_rcu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_for_each_safe_rcu</refname>
 <refpurpose>
     	iterate over an rcu-protected list safe
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_for_each_safe_rcu </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>n</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the &amp;struct list_head to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     		another &amp;struct list_head to use as temporary storage
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This list-traversal primitive may safely run concurrently with
   the _rcu list-mutation primitives such as <function>list_add_rcu</function>
   as long as the traversal is guarded by <function>rcu_read_lock</function>.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This list-traversal primitive may safely run concurrently with
   the _rcu list-mutation primitives such as <function>list_add_rcu</function>
   as long as the traversal is guarded by <function>rcu_read_lock</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-for-each-entry-rcu">list_for_each_entry_rcu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_for_each_entry_rcu</refname>
 <refpurpose>
     	iterate over rcu list of given type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_for_each_entry_rcu </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the type * to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     	the name of the list_struct within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This list-traversal primitive may safely run concurrently with
   the _rcu list-mutation primitives such as <function>list_add_rcu</function>
   as long as the traversal is guarded by <function>rcu_read_lock</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-list-for-each-continue-rcu">list_for_each_continue_rcu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>list_for_each_continue_rcu</refname>
 <refpurpose>
     	iterate over an rcu-protected list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>list_for_each_continue_rcu </function></funcdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the &amp;struct list_head to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This list-traversal primitive may safely run concurrently with
   the _rcu list-mutation primitives such as <function>list_add_rcu</function>
   as long as the traversal is guarded by <function>rcu_read_lock</function>.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This list-traversal primitive may safely run concurrently with
   the _rcu list-mutation primitives such as <function>list_add_rcu</function>
   as long as the traversal is guarded by <function>rcu_read_lock</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-hlist-del-rcu">hlist_del_rcu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>hlist_del_rcu</refname>
 <refpurpose>
      deletes entry from hash list without re-initialization
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>hlist_del_rcu </function></funcdef>
   <paramdef>struct hlist_node * <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
      the element to delete from the hash list.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Note</title>
 <para>
    <function>list_unhashed</function> on entry does not return true after this,
   the entry is in an undefined state. It is useful for RCU based
   lockfree traversal.
   </para><para>

   In particular, it means that we can not poison the forward
   pointers that may still be used for walking the hash list.
   </para><para>

   The caller must take whatever precautions are necessary
   (such as holding appropriate locks) to avoid racing
   with another list-mutation primitive, such as <function>hlist_add_head_rcu</function>
   or <function>hlist_del_rcu</function>, running on this same list.
   However, it is perfectly legal to run concurrently with
   the _rcu list-traversal primitives, such as
   <function>hlist_for_each_entry</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-hlist-add-head-rcu">hlist_add_head_rcu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>hlist_add_head_rcu</refname>
 <refpurpose>
      adds the specified element to the specified hlist,
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>hlist_add_head_rcu </function></funcdef>
   <paramdef>struct hlist_node * <parameter>n</parameter></paramdef>
   <paramdef>struct hlist_head * <parameter>h</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
      the element to add to the hash list.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>h</parameter></term>
   <listitem>
    <para>
      the list to add to.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The caller must take whatever precautions are necessary
   (such as holding appropriate locks) to avoid racing
   with another list-mutation primitive, such as <function>hlist_add_head_rcu</function>
   or <function>hlist_del_rcu</function>, running on this same list.
   However, it is perfectly legal to run concurrently with
   the _rcu list-traversal primitives, such as
   <function>hlist_for_each_rcu</function>, used to prevent memory-consistency
   problems on Alpha CPUs.  Regardless of the type of CPU, the
   list-traversal primitive must be guarded by <function>rcu_read_lock</function>.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The caller must take whatever precautions are necessary
   (such as holding appropriate locks) to avoid racing
   with another list-mutation primitive, such as <function>hlist_add_head_rcu</function>
   or <function>hlist_del_rcu</function>, running on this same list.
   However, it is perfectly legal to run concurrently with
   the _rcu list-traversal primitives, such as
   <function>hlist_for_each_rcu</function>, used to prevent memory-consistency
   problems on Alpha CPUs.  Regardless of the type of CPU, the
   list-traversal primitive must be guarded by <function>rcu_read_lock</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-hlist-for-each-entry">hlist_for_each_entry</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>hlist_for_each_entry</refname>
 <refpurpose>
      iterate over list of given type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>hlist_for_each_entry </function></funcdef>
   <paramdef> <parameter>tpos</parameter></paramdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tpos</parameter></term>
   <listitem>
    <para>
     	the type * to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the &amp;struct hlist_node to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     	the name of the hlist_node within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-hlist-for-each-entry-continue">hlist_for_each_entry_continue</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>hlist_for_each_entry_continue</refname>
 <refpurpose>
      iterate over a hlist continuing after existing point
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>hlist_for_each_entry_continue </function></funcdef>
   <paramdef> <parameter>tpos</parameter></paramdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tpos</parameter></term>
   <listitem>
    <para>
     	the type * to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the &amp;struct hlist_node to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     	the name of the hlist_node within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-hlist-for-each-entry-from">hlist_for_each_entry_from</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>hlist_for_each_entry_from</refname>
 <refpurpose>
      iterate over a hlist continuing from existing point
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>hlist_for_each_entry_from </function></funcdef>
   <paramdef> <parameter>tpos</parameter></paramdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tpos</parameter></term>
   <listitem>
    <para>
     	the type * to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the &amp;struct hlist_node to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     	the name of the hlist_node within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-hlist-for-each-entry-safe">hlist_for_each_entry_safe</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>hlist_for_each_entry_safe</refname>
 <refpurpose>
      iterate over list of given type safe against removal of list entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>hlist_for_each_entry_safe </function></funcdef>
   <paramdef> <parameter>tpos</parameter></paramdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>n</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tpos</parameter></term>
   <listitem>
    <para>
     	the type * to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the &amp;struct hlist_node to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     		another &amp;struct hlist_node to use as temporary storage
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     	the name of the hlist_node within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-hlist-for-each-entry-rcu">hlist_for_each_entry_rcu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>hlist_for_each_entry_rcu</refname>
 <refpurpose>
      iterate over rcu list of given type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>hlist_for_each_entry_rcu </function></funcdef>
   <paramdef> <parameter>tpos</parameter></paramdef>
   <paramdef> <parameter>pos</parameter></paramdef>
   <paramdef> <parameter>head</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tpos</parameter></term>
   <listitem>
    <para>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pos</parameter></term>
   <listitem>
    <para>
     	the &amp;struct hlist_node to use as a loop counter.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     	the head for your list.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     	the name of the hlist_node within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This list-traversal primitive may safely run concurrently with
   the _rcu list-mutation primitives such as <function>hlist_add_rcu</function>
   as long as the traversal is guarded by <function>rcu_read_lock</function>.
 </para>
</refsect1>
</refentry>

     </sect1>
  </chapter>

  <chapter id="libc">
     <title>Basic C Library Functions</title>

     <para>
       When writing drivers, you cannot in general use routines which are
       from the C Library.  Some of the functions have been found generally
       useful and they are listed below.  The behaviour of these functions
       may vary slightly from those defined by ANSI, and these deviations
       are noted in the text.
     </para>

     <sect1><title>String Conversions</title>
<!-- lib/vsprintf.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-simple-strtoll">simple_strtoll</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>simple_strtoll</refname>
 <refpurpose>
   convert a string to a signed long long
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long long <function>simple_strtoll </function></funcdef>
   <paramdef>const char * <parameter>cp</parameter></paramdef>
   <paramdef>char ** <parameter>endp</parameter></paramdef>
   <paramdef>unsigned int <parameter>base</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cp</parameter></term>
   <listitem>
    <para>
      The start of the string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>endp</parameter></term>
   <listitem>
    <para>
      A pointer to the end of the parsed string will be placed here
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base</parameter></term>
   <listitem>
    <para>
      The number base to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- lib/vsprintf.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-simple-strtoul">simple_strtoul</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>simple_strtoul</refname>
 <refpurpose>
   convert a string to an unsigned long
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>simple_strtoul </function></funcdef>
   <paramdef>const char * <parameter>cp</parameter></paramdef>
   <paramdef>char ** <parameter>endp</parameter></paramdef>
   <paramdef>unsigned int <parameter>base</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cp</parameter></term>
   <listitem>
    <para>
      The start of the string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>endp</parameter></term>
   <listitem>
    <para>
      A pointer to the end of the parsed string will be placed here
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base</parameter></term>
   <listitem>
    <para>
      The number base to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-simple-strtol">simple_strtol</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>simple_strtol</refname>
 <refpurpose>
      convert a string to a signed long
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>simple_strtol </function></funcdef>
   <paramdef>const char * <parameter>cp</parameter></paramdef>
   <paramdef>char ** <parameter>endp</parameter></paramdef>
   <paramdef>unsigned int <parameter>base</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cp</parameter></term>
   <listitem>
    <para>
      The start of the string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>endp</parameter></term>
   <listitem>
    <para>
      A pointer to the end of the parsed string will be placed here
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base</parameter></term>
   <listitem>
    <para>
      The number base to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-simple-strtoull">simple_strtoull</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>simple_strtoull</refname>
 <refpurpose>
      convert a string to an unsigned long long
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long long <function>simple_strtoull </function></funcdef>
   <paramdef>const char * <parameter>cp</parameter></paramdef>
   <paramdef>char ** <parameter>endp</parameter></paramdef>
   <paramdef>unsigned int <parameter>base</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cp</parameter></term>
   <listitem>
    <para>
      The start of the string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>endp</parameter></term>
   <listitem>
    <para>
      A pointer to the end of the parsed string will be placed here
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base</parameter></term>
   <listitem>
    <para>
      The number base to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-vsnprintf">vsnprintf</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>vsnprintf</refname>
 <refpurpose>
      Format a string and place it in a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>vsnprintf </function></funcdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef>va_list <parameter>args</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
      The buffer to place the result into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      The size of the buffer, including the trailing null space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
      The format string to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
      Arguments for the format string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The return value is the number of characters which would
   be generated for the given input, excluding the trailing
   '\0', as per ISO C99. If you want to have the exact
   number of characters written into <parameter>buf</parameter> as return value
   (not including the trailing '\0'), use vscnprintf. If the
   return is greater than or equal to <parameter>size</parameter>, the resulting
   string is truncated.
   </para><para>

   Call this function if you are already dealing with a va_list.
   You probably want snprintf instead.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-vscnprintf">vscnprintf</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>vscnprintf</refname>
 <refpurpose>
      Format a string and place it in a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>vscnprintf </function></funcdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef>va_list <parameter>args</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
      The buffer to place the result into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      The size of the buffer, including the trailing null space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
      The format string to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
      Arguments for the format string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The return value is the number of characters which have been written into
   the <parameter>buf</parameter> not including the trailing '\0'. If <parameter>size</parameter> is &lt;= 0 the function
   returns 0.
   </para><para>

   Call this function if you are already dealing with a va_list.
   You probably want scnprintf instead.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-snprintf">snprintf</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>snprintf</refname>
 <refpurpose>
      Format a string and place it in a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snprintf </function></funcdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
      The buffer to place the result into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      The size of the buffer, including the trailing null space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
      The format string to use
     @...: Arguments for the format string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The return value is the number of characters which would be
   generated for the given input, excluding the trailing null,
   as per ISO C99.  If the return is greater than or equal to
   <parameter>size</parameter>, the resulting string is truncated.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-scnprintf">scnprintf</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>scnprintf</refname>
 <refpurpose>
      Format a string and place it in a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>scnprintf </function></funcdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
      The buffer to place the result into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      The size of the buffer, including the trailing null space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
      The format string to use
     @...: Arguments for the format string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The return value is the number of characters written into <parameter>buf</parameter> not including
   the trailing '\0'. If <parameter>size</parameter> is &lt;= 0 the function returns 0. If the return is
   greater than or equal to <parameter>size</parameter>, the resulting string is truncated.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-vsprintf">vsprintf</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>vsprintf</refname>
 <refpurpose>
      Format a string and place it in a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>vsprintf </function></funcdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef>va_list <parameter>args</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
      The buffer to place the result into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
      The format string to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
      Arguments for the format string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The function returns the number of characters written
   into <parameter>buf</parameter>. Use vsnprintf or vscnprintf in order to avoid
   buffer overflows.
   </para><para>

   Call this function if you are already dealing with a va_list.
   You probably want sprintf instead.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sprintf">sprintf</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sprintf</refname>
 <refpurpose>
      Format a string and place it in a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sprintf </function></funcdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
      The buffer to place the result into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
      The format string to use
     @...: Arguments for the format string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The function returns the number of characters written
   into <parameter>buf</parameter>. Use snprintf or scnprintf in order to avoid
   buffer overflows.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-vsscanf">vsscanf</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>vsscanf</refname>
 <refpurpose>
      Unformat a buffer into a list of arguments
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>vsscanf </function></funcdef>
   <paramdef>const char * <parameter>buf</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef>va_list <parameter>args</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     	input buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     	format of buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     	arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sscanf">sscanf</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sscanf</refname>
 <refpurpose>
      Unformat a buffer into a list of arguments
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sscanf </function></funcdef>
   <paramdef>const char * <parameter>buf</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     	input buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     	formatting of buffer
     @...:	resulting arguments
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>String Manipulation</title>
<!-- lib/string.c -->
<refentry>
 <refnamediv>
  <refname>
   /home/liuhaozzu/repoes/linux/kernels/linux-2.6.11/lib/string.c
  </refname>
  <refpurpose>
   Document generation inconsistency
  </refpurpose>
 </refnamediv>
 <refsect1>
  <title>
   Oops
  </title>
  <warning>
   <para>
    The template for this document tried to insert
    the structured comment from the file
    <filename>/home/liuhaozzu/repoes/linux/kernels/linux-2.6.11/lib/string.c</filename> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </para>
  </warning>
 </refsect1>
</refentry>
<!-- lib/string.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-strnicmp">strnicmp</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strnicmp</refname>
 <refpurpose>
   Case insensitive, length-limited string comparison
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>strnicmp </function></funcdef>
   <paramdef>const char * <parameter>s1</parameter></paramdef>
   <paramdef>const char * <parameter>s2</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s1</parameter></term>
   <listitem>
    <para>
      One string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>s2</parameter></term>
   <listitem>
    <para>
      The other string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
      the maximum number of characters to compare
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strcpy">strcpy</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strcpy</refname>
 <refpurpose>
      Copy a <constant>NUL</constant> terminated string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>strcpy </function></funcdef>
   <paramdef>char * <parameter>dest</parameter></paramdef>
   <paramdef>const char * <parameter>src</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dest</parameter></term>
   <listitem>
    <para>
      Where to copy the string to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
      Where to copy the string from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strncpy">strncpy</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strncpy</refname>
 <refpurpose>
      Copy a length-limited, <constant>NUL-terminated</constant> string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>strncpy </function></funcdef>
   <paramdef>char * <parameter>dest</parameter></paramdef>
   <paramdef>const char * <parameter>src</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dest</parameter></term>
   <listitem>
    <para>
      Where to copy the string to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
      Where to copy the string from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      The maximum number of bytes to copy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The result is not <constant>NUL-terminated</constant> if the source exceeds
   <parameter>count</parameter> bytes.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strlcpy">strlcpy</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strlcpy</refname>
 <refpurpose>
      Copy a <constant>NUL</constant> terminated string into a sized buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>strlcpy </function></funcdef>
   <paramdef>char * <parameter>dest</parameter></paramdef>
   <paramdef>const char * <parameter>src</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dest</parameter></term>
   <listitem>
    <para>
      Where to copy the string to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
      Where to copy the string from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      size of destination buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>BSD</title>
 <para>
    the result is always a valid
   NUL-terminated string that fits in the buffer (unless,
   of course, the buffer size is zero). It does not pad
   out the result like <function>strncpy</function> does.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strcat">strcat</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strcat</refname>
 <refpurpose>
      Append one <constant>NUL-terminated</constant> string to another
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>strcat </function></funcdef>
   <paramdef>char * <parameter>dest</parameter></paramdef>
   <paramdef>const char * <parameter>src</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dest</parameter></term>
   <listitem>
    <para>
      The string to be appended to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
      The string to append to it
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strncat">strncat</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strncat</refname>
 <refpurpose>
      Append a length-limited, <constant>NUL-terminated</constant> string to another
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>strncat </function></funcdef>
   <paramdef>char * <parameter>dest</parameter></paramdef>
   <paramdef>const char * <parameter>src</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dest</parameter></term>
   <listitem>
    <para>
      The string to be appended to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
      The string to append to it
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      The maximum numbers of bytes to copy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Note that in contrast to strncpy, strncat ensures the result is
   terminated.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strlcat">strlcat</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strlcat</refname>
 <refpurpose>
      Append a length-limited, <constant>NUL-terminated</constant> string to another
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>strlcat </function></funcdef>
   <paramdef>char * <parameter>dest</parameter></paramdef>
   <paramdef>const char * <parameter>src</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dest</parameter></term>
   <listitem>
    <para>
      The string to be appended to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
      The string to append to it
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      The size of the destination buffer.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strcmp">strcmp</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strcmp</refname>
 <refpurpose>
      Compare two strings
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>strcmp </function></funcdef>
   <paramdef>const char * <parameter>cs</parameter></paramdef>
   <paramdef>const char * <parameter>ct</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cs</parameter></term>
   <listitem>
    <para>
      One string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ct</parameter></term>
   <listitem>
    <para>
      Another string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strncmp">strncmp</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strncmp</refname>
 <refpurpose>
      Compare two length-limited strings
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>strncmp </function></funcdef>
   <paramdef>const char * <parameter>cs</parameter></paramdef>
   <paramdef>const char * <parameter>ct</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cs</parameter></term>
   <listitem>
    <para>
      One string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ct</parameter></term>
   <listitem>
    <para>
      Another string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      The maximum number of bytes to compare
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strchr">strchr</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strchr</refname>
 <refpurpose>
      Find the first occurrence of a character in a string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>strchr </function></funcdef>
   <paramdef>const char * <parameter>s</parameter></paramdef>
   <paramdef>int <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
      The string to be searched
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      The character to search for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strrchr">strrchr</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strrchr</refname>
 <refpurpose>
      Find the last occurrence of a character in a string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>strrchr </function></funcdef>
   <paramdef>const char * <parameter>s</parameter></paramdef>
   <paramdef>int <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
      The string to be searched
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      The character to search for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strnchr">strnchr</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strnchr</refname>
 <refpurpose>
      Find a character in a length limited string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>strnchr </function></funcdef>
   <paramdef>const char * <parameter>s</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
   <paramdef>int <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
      The string to be searched
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      The number of characters to be searched
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      The character to search for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strlen">strlen</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strlen</refname>
 <refpurpose>
      Find the length of a string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>strlen </function></funcdef>
   <paramdef>const char * <parameter>s</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
      The string to be sized
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strnlen">strnlen</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strnlen</refname>
 <refpurpose>
      Find the length of a length-limited string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>strnlen </function></funcdef>
   <paramdef>const char * <parameter>s</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
      The string to be sized
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      The maximum number of bytes to search
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strspn">strspn</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strspn</refname>
 <refpurpose>
      Calculate the length of the initial substring of <parameter>s</parameter> which only
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>strspn </function></funcdef>
   <paramdef>const char * <parameter>s</parameter></paramdef>
   <paramdef>const char * <parameter>accept</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
      The string to be searched
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>accept</parameter></term>
   <listitem>
    <para>
      The string to search for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   contain letters in <parameter>accept</parameter>
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strcspn">strcspn</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strcspn</refname>
 <refpurpose>
      Calculate the length of the initial substring of <parameter>s</parameter> which does
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>strcspn </function></funcdef>
   <paramdef>const char * <parameter>s</parameter></paramdef>
   <paramdef>const char * <parameter>reject</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
      The string to be searched
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reject</parameter></term>
   <listitem>
    <para>
      The string to avoid
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   not contain letters in <parameter>reject</parameter>
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strpbrk">strpbrk</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strpbrk</refname>
 <refpurpose>
      Find the first occurrence of a set of characters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>strpbrk </function></funcdef>
   <paramdef>const char * <parameter>cs</parameter></paramdef>
   <paramdef>const char * <parameter>ct</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cs</parameter></term>
   <listitem>
    <para>
      The string to be searched
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ct</parameter></term>
   <listitem>
    <para>
      The characters to search for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strsep">strsep</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strsep</refname>
 <refpurpose>
      Split a string into tokens
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>strsep </function></funcdef>
   <paramdef>char ** <parameter>s</parameter></paramdef>
   <paramdef>const char * <parameter>ct</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
      The string to be searched
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ct</parameter></term>
   <listitem>
    <para>
      The characters to search for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>strsep</function> updates <parameter>s</parameter> to point after the token, ready for the next call.
   </para><para>

   It returns empty tokens, too, behaving exactly like the libc function
   of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
   Same semantics, slimmer shape. ;)
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-memset">memset</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>memset</refname>
 <refpurpose>
      Fill a region of memory with the given value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>memset </function></funcdef>
   <paramdef>void * <parameter>s</parameter></paramdef>
   <paramdef>int <parameter>c</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
      Pointer to the start of the area.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      The byte to fill the area with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      The size of the area.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Do not use <function>memset</function> to access IO space, use <function>memset_io</function> instead.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-memcpy">memcpy</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>memcpy</refname>
 <refpurpose>
      Copy one area of memory to another
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>memcpy </function></funcdef>
   <paramdef>void * <parameter>dest</parameter></paramdef>
   <paramdef>const void * <parameter>src</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dest</parameter></term>
   <listitem>
    <para>
      Where to copy to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
      Where to copy from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      The size of the area.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   You should not use this function to access IO space, use <function>memcpy_toio</function>
   or <function>memcpy_fromio</function> instead.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-memmove">memmove</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>memmove</refname>
 <refpurpose>
      Copy one area of memory to another
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>memmove </function></funcdef>
   <paramdef>void * <parameter>dest</parameter></paramdef>
   <paramdef>const void * <parameter>src</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dest</parameter></term>
   <listitem>
    <para>
      Where to copy to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
      Where to copy from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      The size of the area.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Unlike <function>memcpy</function>, <function>memmove</function> copes with overlapping areas.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-memcmp">memcmp</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>memcmp</refname>
 <refpurpose>
      Compare two areas of memory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>memcmp </function></funcdef>
   <paramdef>const void * <parameter>cs</parameter></paramdef>
   <paramdef>const void * <parameter>ct</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cs</parameter></term>
   <listitem>
    <para>
      One area of memory
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ct</parameter></term>
   <listitem>
    <para>
      Another area of memory
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      The size of the area.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-memscan">memscan</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>memscan</refname>
 <refpurpose>
      Find a character in an area of memory.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>memscan </function></funcdef>
   <paramdef>void * <parameter>addr</parameter></paramdef>
   <paramdef>int <parameter>c</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      The memory area
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      The byte to search for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      The size of the area.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   returns the address of the first occurrence of <parameter>c</parameter>, or 1 byte past
   the area if <parameter>c</parameter> is not found
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strstr">strstr</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strstr</refname>
 <refpurpose>
      Find the first substring in a <constant>NUL</constant> terminated string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>strstr </function></funcdef>
   <paramdef>const char * <parameter>s1</parameter></paramdef>
   <paramdef>const char * <parameter>s2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s1</parameter></term>
   <listitem>
    <para>
      The string to be searched
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>s2</parameter></term>
   <listitem>
    <para>
      The string to search for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-memchr">memchr</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>memchr</refname>
 <refpurpose>
      Find a character in an area of memory.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>memchr </function></funcdef>
   <paramdef>const void * <parameter>s</parameter></paramdef>
   <paramdef>int <parameter>c</parameter></paramdef>
   <paramdef>size_t <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
      The memory area
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      The byte to search for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
      The size of the area.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   returns the address of the first occurrence of <parameter>c</parameter>, or <constant>NULL</constant>
   if <parameter>c</parameter> is not found
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Bit Operations</title>
<!-- include/asm-i386/bitops.h -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-set-bit">set_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>set_bit</refname>
 <refpurpose>
   Atomically set a bit in memory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>set_bit </function></funcdef>
   <paramdef>int <parameter>nr</parameter></paramdef>
   <paramdef>volatile unsigned long * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nr</parameter></term>
   <listitem>
    <para>
      the bit to set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      the address to start counting from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function is atomic and may not be reordered.  See <function>__set_bit</function>
   if you do not require the atomic guarantees.
 </para>
</refsect1>
<refsect1>
 <title>Note</title>
 <para>
    there are no guarantees that this function will not be reordered
   on non x86 architectures, so if you are writting portable code,
   make sure not to rely on its reordering guarantees.
   </para><para>

   Note that <parameter>nr</parameter> may be almost arbitrarily large; this function is not
   restricted to acting on a single-word quantity.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---set-bit">__set_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__set_bit</refname>
 <refpurpose>
      Set a bit in memory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__set_bit </function></funcdef>
   <paramdef>int <parameter>nr</parameter></paramdef>
   <paramdef>volatile unsigned long * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nr</parameter></term>
   <listitem>
    <para>
      the bit to set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      the address to start counting from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Unlike <function>set_bit</function>, this function is non-atomic and may be reordered.
   If it's called on the same region of memory simultaneously, the effect
   may be that only one operation succeeds.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-clear-bit">clear_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>clear_bit</refname>
 <refpurpose>
      Clears a bit in memory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>clear_bit </function></funcdef>
   <paramdef>int <parameter>nr</parameter></paramdef>
   <paramdef>volatile unsigned long * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nr</parameter></term>
   <listitem>
    <para>
      Bit to clear
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      Address to start counting from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>clear_bit</function> is atomic and may not be reordered.  However, it does
   not contain a memory barrier, so if it is used for locking purposes,
   you should call <function>smp_mb__before_clear_bit</function> and/or <function>smp_mb__after_clear_bit</function>
   in order to ensure changes are visible on other processors.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---change-bit">__change_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__change_bit</refname>
 <refpurpose>
      Toggle a bit in memory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__change_bit </function></funcdef>
   <paramdef>int <parameter>nr</parameter></paramdef>
   <paramdef>volatile unsigned long * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nr</parameter></term>
   <listitem>
    <para>
      the bit to change
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      the address to start counting from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Unlike <function>change_bit</function>, this function is non-atomic and may be reordered.
   If it's called on the same region of memory simultaneously, the effect
   may be that only one operation succeeds.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-change-bit">change_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>change_bit</refname>
 <refpurpose>
      Toggle a bit in memory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>change_bit </function></funcdef>
   <paramdef>int <parameter>nr</parameter></paramdef>
   <paramdef>volatile unsigned long * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nr</parameter></term>
   <listitem>
    <para>
      Bit to change
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      Address to start counting from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>change_bit</function> is atomic and may not be reordered. It may be
   reordered on other architectures than x86.
   Note that <parameter>nr</parameter> may be almost arbitrarily large; this function is not
   restricted to acting on a single-word quantity.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-test-and-set-bit">test_and_set_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>test_and_set_bit</refname>
 <refpurpose>
      Set a bit and return its old value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>test_and_set_bit </function></funcdef>
   <paramdef>int <parameter>nr</parameter></paramdef>
   <paramdef>volatile unsigned long * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nr</parameter></term>
   <listitem>
    <para>
      Bit to set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      Address to count from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This operation is atomic and cannot be reordered.  
   It may be reordered on other architectures than x86.
   It also implies a memory barrier.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---test-and-set-bit">__test_and_set_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__test_and_set_bit</refname>
 <refpurpose>
      Set a bit and return its old value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__test_and_set_bit </function></funcdef>
   <paramdef>int <parameter>nr</parameter></paramdef>
   <paramdef>volatile unsigned long * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nr</parameter></term>
   <listitem>
    <para>
      Bit to set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      Address to count from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This operation is non-atomic and can be reordered.  
   If two examples of this operation race, one can appear to succeed
   but actually fail.  You must protect multiple accesses with a lock.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-test-and-clear-bit">test_and_clear_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>test_and_clear_bit</refname>
 <refpurpose>
      Clear a bit and return its old value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>test_and_clear_bit </function></funcdef>
   <paramdef>int <parameter>nr</parameter></paramdef>
   <paramdef>volatile unsigned long * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nr</parameter></term>
   <listitem>
    <para>
      Bit to clear
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      Address to count from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This operation is atomic and cannot be reordered.
   It can be reorderdered on other architectures other than x86.
   It also implies a memory barrier.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---test-and-clear-bit">__test_and_clear_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__test_and_clear_bit</refname>
 <refpurpose>
      Clear a bit and return its old value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__test_and_clear_bit </function></funcdef>
   <paramdef>int <parameter>nr</parameter></paramdef>
   <paramdef>volatile unsigned long * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nr</parameter></term>
   <listitem>
    <para>
      Bit to clear
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      Address to count from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This operation is non-atomic and can be reordered.  
   If two examples of this operation race, one can appear to succeed
   but actually fail.  You must protect multiple accesses with a lock.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-test-and-change-bit">test_and_change_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>test_and_change_bit</refname>
 <refpurpose>
      Change a bit and return its old value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>test_and_change_bit </function></funcdef>
   <paramdef>int <parameter>nr</parameter></paramdef>
   <paramdef>volatile unsigned long * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nr</parameter></term>
   <listitem>
    <para>
      Bit to change
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      Address to count from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This operation is atomic and cannot be reordered.  
   It also implies a memory barrier.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-test-bit">test_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>test_bit</refname>
 <refpurpose>
      Determine whether a bit is set
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>test_bit </function></funcdef>
   <paramdef>int <parameter>nr</parameter></paramdef>
   <paramdef>const volatile void * <parameter>addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nr</parameter></term>
   <listitem>
    <para>
      bit number to test
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      Address to start counting from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-find-first-zero-bit">find_first_zero_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>find_first_zero_bit</refname>
 <refpurpose>
      find the first zero bit in a memory region
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>find_first_zero_bit </function></funcdef>
   <paramdef>const unsigned long * <parameter>addr</parameter></paramdef>
   <paramdef>unsigned <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      The address to start the search at
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      The maximum size to search
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns the bit-number of the first zero bit, not the number of the byte
   containing a bit.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-find-next-zero-bit">find_next_zero_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>find_next_zero_bit</refname>
 <refpurpose>
      find the first zero bit in a memory region
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>find_next_zero_bit </function></funcdef>
   <paramdef>const unsigned long * <parameter>addr</parameter></paramdef>
   <paramdef>int <parameter>size</parameter></paramdef>
   <paramdef>int <parameter>offset</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      The address to base the search on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      The maximum size to search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
      The bitnumber to start searching at
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-find-first-bit">find_first_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>find_first_bit</refname>
 <refpurpose>
      find the first set bit in a memory region
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>find_first_bit </function></funcdef>
   <paramdef>const unsigned long * <parameter>addr</parameter></paramdef>
   <paramdef>unsigned <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      The address to start the search at
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      The maximum size to search
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns the bit-number of the first set bit, not the number of the byte
   containing a bit.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-find-next-bit">find_next_bit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>find_next_bit</refname>
 <refpurpose>
      find the first set bit in a memory region
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>find_next_bit </function></funcdef>
   <paramdef>const unsigned long * <parameter>addr</parameter></paramdef>
   <paramdef>int <parameter>size</parameter></paramdef>
   <paramdef>int <parameter>offset</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      The address to base the search on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      The maximum size to search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
      The bitnumber to start searching at
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-ffz">ffz</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>ffz</refname>
 <refpurpose>
      find first zero in word.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>ffz </function></funcdef>
   <paramdef>unsigned long <parameter>word</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>word</parameter></term>
   <listitem>
    <para>
      The word to search
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Undefined if no zero exists, so code should check against ~0UL first.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---ffs">__ffs</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__ffs</refname>
 <refpurpose>
      find first bit in word.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>__ffs </function></funcdef>
   <paramdef>unsigned long <parameter>word</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>word</parameter></term>
   <listitem>
    <para>
      The word to search
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Undefined if no bit exists, so code should check against 0 first.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-ffs">ffs</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>ffs</refname>
 <refpurpose>
      find first bit set
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ffs </function></funcdef>
   <paramdef>int <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
      the word to search
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This is defined the same way as
   the libc and compiler builtin ffs routines, therefore
   differs in spirit from the above ffz (man ffs).
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-hweight32">hweight32</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>hweight32</refname>
 <refpurpose>
      returns the hamming weight of a N-bit word
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>hweight32 </function></funcdef>
   <paramdef> <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
      the word to weigh
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The Hamming Weight of a number is the total number of bits set in it.
 </para>
</refsect1>
</refentry>

     </sect1>
  </chapter>

  <chapter id="mm">
     <title>Memory Management in Linux</title>
     <sect1><title>The Slab Cache</title>
<!-- mm/slab.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-kmem-cache-create">kmem_cache_create</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>kmem_cache_create</refname>
 <refpurpose>
   Create a cache.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>kmem_cache_t * <function>kmem_cache_create </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>size_t <parameter>align</parameter></paramdef>
   <paramdef>unsigned long <parameter>flags</parameter></paramdef>
   <paramdef>void (*<parameter>ctor</parameter>)
     <funcparams>void*, kmem_cache_t *, unsigned long</funcparams></paramdef>
   <paramdef>void (*<parameter>dtor</parameter>)
     <funcparams>void*, kmem_cache_t *, unsigned long</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      A string which is used in /proc/slabinfo to identify this cache.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      The size of objects to be created in this cache.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>align</parameter></term>
   <listitem>
    <para>
      The required alignment for the objects.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
      SLAB flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ctor</parameter></term>
   <listitem>
    <para>
      A constructor for the objects.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dtor</parameter></term>
   <listitem>
    <para>
      A destructor for the objects.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns a ptr to the cache on success, NULL on failure.
   Cannot be called within a int, but can be interrupted.
   The <parameter>ctor</parameter> is run when new pages are allocated by the cache
   and the <parameter>dtor</parameter> is run before the pages are handed back.
   </para><para>

   <parameter>name</parameter> must be valid until the cache is destroyed. This implies that
   the module calling this has to destroy the cache before getting 
   unloaded.
   </para><para>

   The flags are
   </para><para>

   <constant>SLAB_POISON</constant> - Poison the slab with a known test pattern (a5a5a5a5)
   to catch references to uninitialised memory.
   </para><para>

   <constant>SLAB_RED_ZONE</constant> - Insert `Red' zones around the allocated memory to check
   for buffer overruns.
   </para><para>

   <constant>SLAB_NO_REAP</constant> - Don't automatically reap this cache when we're under
   memory pressure.
   </para><para>

   <constant>SLAB_HWCACHE_ALIGN</constant> - Align the objects in this cache to a hardware
   cacheline.  This can be beneficial if you're counting cycles as closely
   as davem.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-kmem-cache-shrink">kmem_cache_shrink</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>kmem_cache_shrink</refname>
 <refpurpose>
      Shrink a cache.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kmem_cache_shrink </function></funcdef>
   <paramdef>kmem_cache_t * <parameter>cachep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cachep</parameter></term>
   <listitem>
    <para>
      The cache to shrink.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Releases as many slabs as possible for a cache.
   To help debugging, a zero exit status indicates all slabs were released.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-kmem-cache-destroy">kmem_cache_destroy</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>kmem_cache_destroy</refname>
 <refpurpose>
      delete a cache
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kmem_cache_destroy </function></funcdef>
   <paramdef>kmem_cache_t * <parameter>cachep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cachep</parameter></term>
   <listitem>
    <para>
      the cache to destroy
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Remove a kmem_cache_t object from the slab cache.
   Returns 0 on success.
   </para><para>

   It is expected this function will be called by a module when it is
   unloaded.  This will remove the cache completely, and avoid a duplicate
   cache being allocated each time a module is loaded and unloaded, if the
   module doesn't have persistent in-kernel storage across loads and unloads.
   </para><para>

   The cache must be empty before calling this function.
   </para><para>

   The caller must guarantee that noone will allocate memory from the cache
   during the <function>kmem_cache_destroy</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-kmem-cache-alloc">kmem_cache_alloc</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>kmem_cache_alloc</refname>
 <refpurpose>
      Allocate an object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>kmem_cache_alloc </function></funcdef>
   <paramdef>kmem_cache_t * <parameter>cachep</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cachep</parameter></term>
   <listitem>
    <para>
      The cache to allocate from.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
      See <function>kmalloc</function>.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocate an object from this cache.  The flags are only relevant
   if the cache has no available objects.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-kmem-cache-alloc-node">kmem_cache_alloc_node</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>kmem_cache_alloc_node</refname>
 <refpurpose>
      Allocate an object on the specified node
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>kmem_cache_alloc_node </function></funcdef>
   <paramdef>kmem_cache_t * <parameter>cachep</parameter></paramdef>
   <paramdef>int <parameter>nodeid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cachep</parameter></term>
   <listitem>
    <para>
      The cache to allocate from.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nodeid</parameter></term>
   <listitem>
    <para>
      node number of the target node.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Identical to kmem_cache_alloc, except that this function is slow
   and can sleep. And it will allocate memory on the given node, which
   can improve the performance for cpu bound structures.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---kmalloc">__kmalloc</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__kmalloc</refname>
 <refpurpose>
      allocate memory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>__kmalloc </function></funcdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      how many bytes of memory are required.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
      the type of memory to allocate.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   kmalloc is the normal method of allocating memory
   in the kernel.
   </para><para>

   The <parameter>flags</parameter> argument may be one of:
   </para><para>

   <constant>GFP_USER</constant> - Allocate memory on behalf of user.  May sleep.
   </para><para>

   <constant>GFP_KERNEL</constant> - Allocate normal kernel ram.  May sleep.
   </para><para>

   <constant>GFP_ATOMIC</constant> - Allocation will not sleep.  Use inside interrupt handlers.
   </para><para>

   Additionally, the <constant>GFP_DMA</constant> flag may be set to indicate the memory
   must be suitable for DMA.  This can mean different things on different
   platforms.  For example, on i386, it means that the memory must come
   from the first 16MB.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---alloc-percpu">__alloc_percpu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__alloc_percpu</refname>
 <refpurpose>
      allocate one copy of the object for every present
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>__alloc_percpu </function></funcdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>size_t <parameter>align</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      how many bytes of memory are required.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>align</parameter></term>
   <listitem>
    <para>
      the alignment, which can't be greater than SMP_CACHE_BYTES.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   cpu in the system, zeroing them.
   Objects should be dereferenced using the per_cpu_ptr macro only.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-kmem-cache-free">kmem_cache_free</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>kmem_cache_free</refname>
 <refpurpose>
      Deallocate an object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>kmem_cache_free </function></funcdef>
   <paramdef>kmem_cache_t * <parameter>cachep</parameter></paramdef>
   <paramdef>void * <parameter>objp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cachep</parameter></term>
   <listitem>
    <para>
      The cache the allocation was from.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>objp</parameter></term>
   <listitem>
    <para>
      The previously allocated object.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Free an object which was previously allocated from this
   cache.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-kcalloc">kcalloc</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>kcalloc</refname>
 <refpurpose>
      allocate memory for an array. The memory is set to zero.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>kcalloc </function></funcdef>
   <paramdef>size_t <parameter>n</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
      number of elements.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      element size.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
      the type of memory to allocate.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-kfree">kfree</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>kfree</refname>
 <refpurpose>
      free previously allocated memory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>kfree </function></funcdef>
   <paramdef>const void * <parameter>objp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>objp</parameter></term>
   <listitem>
    <para>
      pointer returned by kmalloc.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Don't free memory not originally allocated by <function>kmalloc</function>
   or you will run into trouble.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-free-percpu">free_percpu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>free_percpu</refname>
 <refpurpose>
      free previously allocated percpu memory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>free_percpu </function></funcdef>
   <paramdef>const void * <parameter>objp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>objp</parameter></term>
   <listitem>
    <para>
      pointer returned by alloc_percpu.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Don't free memory not originally allocated by <function>alloc_percpu</function>
   The complemented objp is to check for that.
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>User Space Memory Access</title>
<!-- include/asm-i386/uaccess.h -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-access-ok">access_ok</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>access_ok</refname>
 <refpurpose>
   Checks if a user space pointer is valid
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>access_ok </function></funcdef>
   <paramdef> <parameter>type</parameter></paramdef>
   <paramdef> <parameter>addr</parameter></paramdef>
   <paramdef> <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
      Type of access: <constant>VERIFY_READ</constant> or <constant>VERIFY_WRITE</constant>.  Note that
     <constant>VERIFY_WRITE</constant> is a superset of <constant>VERIFY_READ</constant> - if it is safe
     to write to a block, it is always safe to read from it.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      User space pointer to start of block to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      Size of block to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Context</title>
 <para>
    User context only.  This function may sleep.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Checks if a pointer to a block of memory in user space is valid.
   </para><para>

   Returns true (nonzero) if the memory block may be valid, false (zero)
   if it is definitely invalid.
   </para><para>

   Note that, depending on architecture, this function probably just
   checks that the pointer is in the user space range - after calling
   this function, memory access functions may still return -EFAULT.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-verify-area">verify_area</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>verify_area</refname>
 <refpurpose>
      Obsolete, use <function>access_ok</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>verify_area </function></funcdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>const void __user * <parameter>addr</parameter></paramdef>
   <paramdef>unsigned long <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
      Type of access: <constant>VERIFY_READ</constant> or <constant>VERIFY_WRITE</constant>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
      User space pointer to start of block to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      Size of block to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Context</title>
 <para>
    User context only.  This function may sleep.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function has been replaced by <function>access_ok</function>.
   </para><para>

   Checks if a pointer to a block of memory in user space is valid.
   </para><para>

   Returns zero if the memory block may be valid, -EFAULT
   if it is definitely invalid.
   </para><para>

   See <function>access_ok</function> for more details.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-get-user">get_user</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>get_user</refname>
 <refpurpose>
      Get a simple variable from user space.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>get_user </function></funcdef>
   <paramdef> <parameter>x</parameter></paramdef>
   <paramdef> <parameter>ptr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
        Variable to store result.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
      Source address, in user space.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Context</title>
 <para>
    User context only.  This function may sleep.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This macro copies a single simple variable from user space to kernel
   space.  It supports simple types like char and int, but not larger
   data types like structures or arrays.
   </para><para>

   <parameter>ptr</parameter> must have pointer-to-simple-variable type, and the result of
   dereferencing <parameter>ptr</parameter> must be assignable to <parameter>x</parameter> without a cast.
   </para><para>

   Returns zero on success, or -EFAULT on error.
   On error, the variable <parameter>x</parameter> is set to zero.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-put-user">put_user</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>put_user</refname>
 <refpurpose>
      Write a simple value into user space.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>put_user </function></funcdef>
   <paramdef> <parameter>x</parameter></paramdef>
   <paramdef> <parameter>ptr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
        Value to copy to user space.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
      Destination address, in user space.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Context</title>
 <para>
    User context only.  This function may sleep.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This macro copies a single simple value from kernel space to user
   space.  It supports simple types like char and int, but not larger
   data types like structures or arrays.
   </para><para>

   <parameter>ptr</parameter> must have pointer-to-simple-variable type, and <parameter>x</parameter> must be assignable
   to the result of dereferencing <parameter>ptr</parameter>.
   </para><para>

   Returns zero on success, or -EFAULT on error.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---get-user">__get_user</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__get_user</refname>
 <refpurpose>
      Get a simple variable from user space, with less checking.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>__get_user </function></funcdef>
   <paramdef> <parameter>x</parameter></paramdef>
   <paramdef> <parameter>ptr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
        Variable to store result.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
      Source address, in user space.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Context</title>
 <para>
    User context only.  This function may sleep.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This macro copies a single simple variable from user space to kernel
   space.  It supports simple types like char and int, but not larger
   data types like structures or arrays.
   </para><para>

   <parameter>ptr</parameter> must have pointer-to-simple-variable type, and the result of
   dereferencing <parameter>ptr</parameter> must be assignable to <parameter>x</parameter> without a cast.
   </para><para>

   Caller must check the pointer with <function>access_ok</function> before calling this
   function.
   </para><para>

   Returns zero on success, or -EFAULT on error.
   On error, the variable <parameter>x</parameter> is set to zero.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---put-user">__put_user</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__put_user</refname>
 <refpurpose>
      Write a simple value into user space, with less checking.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>__put_user </function></funcdef>
   <paramdef> <parameter>x</parameter></paramdef>
   <paramdef> <parameter>ptr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
        Value to copy to user space.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
      Destination address, in user space.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Context</title>
 <para>
    User context only.  This function may sleep.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This macro copies a single simple value from kernel space to user
   space.  It supports simple types like char and int, but not larger
   data types like structures or arrays.
   </para><para>

   <parameter>ptr</parameter> must have pointer-to-simple-variable type, and <parameter>x</parameter> must be assignable
   to the result of dereferencing <parameter>ptr</parameter>.
   </para><para>

   Caller must check the pointer with <function>access_ok</function> before calling this
   function.
   </para><para>

   Returns zero on success, or -EFAULT on error.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---copy-to-user-inatomic">__copy_to_user_inatomic</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__copy_to_user_inatomic</refname>
 <refpurpose>
      Copy a block of data into user space, with less checking.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long __must_check <function>__copy_to_user_inatomic </function></funcdef>
   <paramdef>void __user * <parameter>to</parameter></paramdef>
   <paramdef>const void * <parameter>from</parameter></paramdef>
   <paramdef>unsigned long <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
        Destination address, in user space.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
      Source address, in kernel space.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
         Number of bytes to copy.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Context</title>
 <para>
    User context only.  This function may sleep.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Copy data from kernel space to user space.  Caller must check
   the specified block with <function>access_ok</function> before calling this function.
   </para><para>

   Returns number of bytes that could not be copied.
   On success, this will be zero.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---copy-from-user-inatomic">__copy_from_user_inatomic</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__copy_from_user_inatomic</refname>
 <refpurpose>
      Copy a block of data from user space, with less checking.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>__copy_from_user_inatomic </function></funcdef>
   <paramdef>void * <parameter>to</parameter></paramdef>
   <paramdef>const void __user * <parameter>from</parameter></paramdef>
   <paramdef>unsigned long <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
        Destination address, in kernel space.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
      Source address, in user space.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
         Number of bytes to copy.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Context</title>
 <para>
    User context only.  This function may sleep.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Copy data from user space to kernel space.  Caller must check
   the specified block with <function>access_ok</function> before calling this function.
   </para><para>

   Returns number of bytes that could not be copied.
   On success, this will be zero.
   </para><para>

   If some data could not be copied, this function will pad the copied
   data to the requested size using zero bytes.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strlen-user">strlen_user</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strlen_user</refname>
 <refpurpose>
      Get the size of a string in user space.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>strlen_user </function></funcdef>
   <paramdef> <parameter>str</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>str</parameter></term>
   <listitem>
    <para>
      The string to measure.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Context</title>
 <para>
    User context only.  This function may sleep.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Get the size of a NUL-terminated string in user space.
   </para><para>

   Returns the size of the string INCLUDING the terminating NUL.
   On exception, returns 0.
   </para><para>

   If there is a limit on the length of a valid string, you may wish to
   consider using <function>strnlen_user</function> instead.
 </para>
</refsect1>
</refentry>

<!-- arch/i386/lib/usercopy.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API---strncpy-from-user">__strncpy_from_user</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__strncpy_from_user</refname>
 <refpurpose>
   Copy a NUL terminated string from userspace, with less checking.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>__strncpy_from_user </function></funcdef>
   <paramdef>char * <parameter>dst</parameter></paramdef>
   <paramdef>const char __user * <parameter>src</parameter></paramdef>
   <paramdef>long <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
        Destination address, in kernel space.  This buffer must be at
     least <parameter>count</parameter> bytes long.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
        Source address, in user space.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      Maximum number of bytes to copy, including the trailing NUL.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Copies a NUL-terminated string from userspace to kernel space.
   Caller must check the specified block with <function>access_ok</function> before calling
   this function.
   </para><para>

   On success, returns the length of the string (not including the trailing
   NUL).
   </para><para>

   If access to userspace fails, returns -EFAULT (some data may have been
   copied).
   </para><para>

   If <parameter>count</parameter> is smaller than the length of the string, copies <parameter>count</parameter> bytes
   and returns <parameter>count</parameter>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strncpy-from-user">strncpy_from_user</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strncpy_from_user</refname>
 <refpurpose>
      Copy a NUL terminated string from userspace.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>strncpy_from_user </function></funcdef>
   <paramdef>char * <parameter>dst</parameter></paramdef>
   <paramdef>const char __user * <parameter>src</parameter></paramdef>
   <paramdef>long <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
        Destination address, in kernel space.  This buffer must be at
     least <parameter>count</parameter> bytes long.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
        Source address, in user space.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      Maximum number of bytes to copy, including the trailing NUL.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Copies a NUL-terminated string from userspace to kernel space.
   </para><para>

   On success, returns the length of the string (not including the trailing
   NUL).
   </para><para>

   If access to userspace fails, returns -EFAULT (some data may have been
   copied).
   </para><para>

   If <parameter>count</parameter> is smaller than the length of the string, copies <parameter>count</parameter> bytes
   and returns <parameter>count</parameter>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-clear-user">clear_user</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>clear_user</refname>
 <refpurpose>
      Zero a block of memory in user space.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>clear_user </function></funcdef>
   <paramdef>void __user * <parameter>to</parameter></paramdef>
   <paramdef>unsigned long <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
        Destination address, in user space.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
         Number of bytes to zero.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Zero a block of memory in user space.
   </para><para>

   Returns number of bytes that could not be cleared.
   On success, this will be zero.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---clear-user">__clear_user</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__clear_user</refname>
 <refpurpose>
      Zero a block of memory in user space, with less checking.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>__clear_user </function></funcdef>
   <paramdef>void __user * <parameter>to</parameter></paramdef>
   <paramdef>unsigned long <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
        Destination address, in user space.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
         Number of bytes to zero.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Zero a block of memory in user space.  Caller must check
   the specified block with <function>access_ok</function> before calling this function.
   </para><para>

   Returns number of bytes that could not be cleared.
   On success, this will be zero.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-strnlen-user">strnlen_user</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>strnlen_user</refname>
 <refpurpose>
      Get the size of a string in user space.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>strnlen_user </function></funcdef>
   <paramdef>const char __user * <parameter>s</parameter></paramdef>
   <paramdef>long <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
      The string to measure.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
      The maximum valid length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Get the size of a NUL-terminated string in user space.
   </para><para>

   Returns the size of the string INCLUDING the terminating NUL.
   On exception, returns 0.
   If the string is too long, returns a value greater than <parameter>n</parameter>.
 </para>
</refsect1>
</refentry>

     </sect1>
  </chapter>

  <chapter id="proc">
     <title>The proc filesystem</title>
 
     <sect1><title>sysctl interface</title>
<!-- kernel/sysctl.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-sysctl-table">register_sysctl_table</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_sysctl_table</refname>
 <refpurpose>
   register a sysctl hierarchy
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct ctl_table_header * <function>register_sysctl_table </function></funcdef>
   <paramdef>ctl_table * <parameter>table</parameter></paramdef>
   <paramdef>int <parameter>insert_at_head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>table</parameter></term>
   <listitem>
    <para>
      the top-level table structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>insert_at_head</parameter></term>
   <listitem>
    <para>
      whether the entry should be inserted in front or at the end
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Register a sysctl table hierarchy. <parameter>table</parameter> should be a filled in ctl_table
   array. An entry with a ctl_name of 0 terminates the table. 
   </para><para>

   The members of the &amp;ctl_table structure are used as follows:
   </para><para>

   ctl_name - This is the numeric sysctl value used by sysctl(2). The number
   must be unique within that level of sysctl
   </para><para>

   procname - the name of the sysctl file under /proc/sys. Set to <constant>NULL</constant> to not
   enter a sysctl file
   </para><para>

   data - a pointer to data for use by proc_handler
   </para><para>

   maxlen - the maximum size in bytes of the data
   </para><para>

   mode - the file permissions for the /proc/sys file, and for sysctl(2)
   </para><para>

   child - a pointer to the child sysctl table if this entry is a directory, or
   <constant>NULL</constant>.
   </para><para>

   proc_handler - the text handler routine (described below)
   </para><para>

   strategy - the strategy routine (described below)
   </para><para>

   de - for internal use by the sysctl routines
   </para><para>

   extra1, extra2 - extra pointers usable by the proc handler routines
   </para><para>

   Leaf nodes in the sysctl tree will be represented by a single file
   under /proc; non-leaf nodes will be represented by directories.
   </para><para>

   sysctl(2) can automatically manage read and write requests through
   the sysctl table.  The data and maxlen fields of the ctl_table
   struct enable minimal validation of the values being written to be
   performed, and the mode field allows minimal authentication.
   </para><para>

   More sophisticated management can be enabled by the provision of a
   strategy routine with the table entry.  This will be called before
   any automatic read or write of the data is performed.
   </para><para>

   The strategy routine may return
   </para><para>

   &lt; 0 - Error occurred (error is passed to user process)
   </para><para>

   0   - OK - proceed with automatic read or write.
   </para><para>

   &gt; 0 - OK - read or write has been done by the strategy routine, so
   return immediately.
   </para><para>

   There must be a proc_handler routine for any terminal nodes
   mirrored under /proc/sys (non-terminals are handled by a built-in
   directory handler).  Several default handlers are available to
   cover common cases -
   </para><para>

   <function>proc_dostring</function>, <function>proc_dointvec</function>, <function>proc_dointvec_jiffies</function>,
   <function>proc_dointvec_userhz_jiffies</function>, <function>proc_dointvec_minmax</function>, 
   <function>proc_doulongvec_ms_jiffies_minmax</function>, <function>proc_doulongvec_minmax</function>
   </para><para>

   It is the handler's job to read the input buffer from user memory
   and process it. The handler should return 0 on success.
   </para><para>

   This routine returns <constant>NULL</constant> on a failure to register, and a pointer
   to the table header on success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-unregister-sysctl-table">unregister_sysctl_table</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>unregister_sysctl_table</refname>
 <refpurpose>
      unregister a sysctl table hierarchy
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_sysctl_table </function></funcdef>
   <paramdef>struct ctl_table_header * <parameter>header</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>header</parameter></term>
   <listitem>
    <para>
      the header returned from register_sysctl_table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Unregisters the sysctl table and all children. proc entries may not
   actually be removed until they are no longer used by anyone.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-proc-dostring">proc_dostring</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>proc_dostring</refname>
 <refpurpose>
      read a string sysctl
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>proc_dostring </function></funcdef>
   <paramdef>ctl_table * <parameter>table</parameter></paramdef>
   <paramdef>int <parameter>write</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>void __user * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t * <parameter>lenp</parameter></paramdef>
   <paramdef>loff_t * <parameter>ppos</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>table</parameter></term>
   <listitem>
    <para>
      the sysctl table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>write</parameter></term>
   <listitem>
    <para>
      <constant>TRUE</constant> if this is a write to the sysctl file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      the file structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lenp</parameter></term>
   <listitem>
    <para>
      the size of the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ppos</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Reads/writes a string from/to the user buffer. If the kernel
   buffer provided is not large enough to hold the string, the
   string is truncated. The copied string is <constant>NULL-terminated</constant>.
   If the string is being read by the user process, it is copied
   and a newline '\n' is added. It is truncated if the buffer is
   not large enough.
   </para><para>

   Returns 0 on success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-proc-dointvec">proc_dointvec</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>proc_dointvec</refname>
 <refpurpose>
      read a vector of integers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>proc_dointvec </function></funcdef>
   <paramdef>ctl_table * <parameter>table</parameter></paramdef>
   <paramdef>int <parameter>write</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>void __user * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t * <parameter>lenp</parameter></paramdef>
   <paramdef>loff_t * <parameter>ppos</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>table</parameter></term>
   <listitem>
    <para>
      the sysctl table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>write</parameter></term>
   <listitem>
    <para>
      <constant>TRUE</constant> if this is a write to the sysctl file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      the file structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lenp</parameter></term>
   <listitem>
    <para>
      the size of the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ppos</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
   values from/to the user buffer, treated as an ASCII string. 
   </para><para>

   Returns 0 on success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-proc-dointvec-minmax">proc_dointvec_minmax</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>proc_dointvec_minmax</refname>
 <refpurpose>
      read a vector of integers with min/max values
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>proc_dointvec_minmax </function></funcdef>
   <paramdef>ctl_table * <parameter>table</parameter></paramdef>
   <paramdef>int <parameter>write</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>void __user * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t * <parameter>lenp</parameter></paramdef>
   <paramdef>loff_t * <parameter>ppos</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>table</parameter></term>
   <listitem>
    <para>
      the sysctl table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>write</parameter></term>
   <listitem>
    <para>
      <constant>TRUE</constant> if this is a write to the sysctl file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      the file structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lenp</parameter></term>
   <listitem>
    <para>
      the size of the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ppos</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
   values from/to the user buffer, treated as an ASCII string.
   </para><para>

   This routine will ensure the values are within the range specified by
   table-&gt;extra1 (min) and table-&gt;extra2 (max).
   </para><para>

   Returns 0 on success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-proc-doulongvec-minmax">proc_doulongvec_minmax</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>proc_doulongvec_minmax</refname>
 <refpurpose>
      read a vector of long integers with min/max values
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>proc_doulongvec_minmax </function></funcdef>
   <paramdef>ctl_table * <parameter>table</parameter></paramdef>
   <paramdef>int <parameter>write</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>void __user * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t * <parameter>lenp</parameter></paramdef>
   <paramdef>loff_t * <parameter>ppos</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>table</parameter></term>
   <listitem>
    <para>
      the sysctl table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>write</parameter></term>
   <listitem>
    <para>
      <constant>TRUE</constant> if this is a write to the sysctl file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      the file structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lenp</parameter></term>
   <listitem>
    <para>
      the size of the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ppos</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Reads/writes up to table-&gt;maxlen/sizeof(unsigned long) unsigned long
   values from/to the user buffer, treated as an ASCII string.
   </para><para>

   This routine will ensure the values are within the range specified by
   table-&gt;extra1 (min) and table-&gt;extra2 (max).
   </para><para>

   Returns 0 on success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-proc-doulongvec-ms-jiffies-minmax">proc_doulongvec_ms_jiffies_minmax</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>proc_doulongvec_ms_jiffies_minmax</refname>
 <refpurpose>
      read a vector of millisecond values with min/max values
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>proc_doulongvec_ms_jiffies_minmax </function></funcdef>
   <paramdef>ctl_table * <parameter>table</parameter></paramdef>
   <paramdef>int <parameter>write</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>void __user * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t * <parameter>lenp</parameter></paramdef>
   <paramdef>loff_t * <parameter>ppos</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>table</parameter></term>
   <listitem>
    <para>
      the sysctl table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>write</parameter></term>
   <listitem>
    <para>
      <constant>TRUE</constant> if this is a write to the sysctl file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      the file structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lenp</parameter></term>
   <listitem>
    <para>
      the size of the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ppos</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Reads/writes up to table-&gt;maxlen/sizeof(unsigned long) unsigned long
   values from/to the user buffer, treated as an ASCII string. The values
   are treated as milliseconds, and converted to jiffies when they are stored.
   </para><para>

   This routine will ensure the values are within the range specified by
   table-&gt;extra1 (min) and table-&gt;extra2 (max).
   </para><para>

   Returns 0 on success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-proc-dointvec-jiffies">proc_dointvec_jiffies</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>proc_dointvec_jiffies</refname>
 <refpurpose>
      read a vector of integers as seconds
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>proc_dointvec_jiffies </function></funcdef>
   <paramdef>ctl_table * <parameter>table</parameter></paramdef>
   <paramdef>int <parameter>write</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>void __user * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t * <parameter>lenp</parameter></paramdef>
   <paramdef>loff_t * <parameter>ppos</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>table</parameter></term>
   <listitem>
    <para>
      the sysctl table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>write</parameter></term>
   <listitem>
    <para>
      <constant>TRUE</constant> if this is a write to the sysctl file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      the file structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lenp</parameter></term>
   <listitem>
    <para>
      the size of the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ppos</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
   values from/to the user buffer, treated as an ASCII string. 
   The values read are assumed to be in seconds, and are converted into
   jiffies.
   </para><para>

   Returns 0 on success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-proc-dointvec-userhz-jiffies">proc_dointvec_userhz_jiffies</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>proc_dointvec_userhz_jiffies</refname>
 <refpurpose>
      read a vector of integers as 1/USER_HZ seconds
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>proc_dointvec_userhz_jiffies </function></funcdef>
   <paramdef>ctl_table * <parameter>table</parameter></paramdef>
   <paramdef>int <parameter>write</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>void __user * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t * <parameter>lenp</parameter></paramdef>
   <paramdef>loff_t * <parameter>ppos</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>table</parameter></term>
   <listitem>
    <para>
      the sysctl table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>write</parameter></term>
   <listitem>
    <para>
      <constant>TRUE</constant> if this is a write to the sysctl file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      the file structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lenp</parameter></term>
   <listitem>
    <para>
      the size of the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ppos</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
   values from/to the user buffer, treated as an ASCII string. 
   The values read are assumed to be in 1/USER_HZ seconds, and 
   are converted into jiffies.
   </para><para>

   Returns 0 on success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-proc-dointvec-ms-jiffies">proc_dointvec_ms_jiffies</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>proc_dointvec_ms_jiffies</refname>
 <refpurpose>
      read a vector of integers as 1 milliseconds
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>proc_dointvec_ms_jiffies </function></funcdef>
   <paramdef>ctl_table * <parameter>table</parameter></paramdef>
   <paramdef>int <parameter>write</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>void __user * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t * <parameter>lenp</parameter></paramdef>
   <paramdef>loff_t * <parameter>ppos</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>table</parameter></term>
   <listitem>
    <para>
      the sysctl table
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>write</parameter></term>
   <listitem>
    <para>
      <constant>TRUE</constant> if this is a write to the sysctl file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      the file structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lenp</parameter></term>
   <listitem>
    <para>
      the size of the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ppos</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
   values from/to the user buffer, treated as an ASCII string. 
   The values read are assumed to be in 1/1000 seconds, and 
   are converted into jiffies.
   </para><para>

   Returns 0 on success.
 </para>
</refsect1>
</refentry>

     </sect1>
  </chapter>

  <chapter id="debugfs">
     <title>The debugfs filesystem</title>
 
     <sect1><title>debugfs interface</title>
<!-- fs/debugfs/inode.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-debugfs-create-file">debugfs_create_file</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>debugfs_create_file</refname>
 <refpurpose>
   create a file in the debugfs filesystem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>debugfs_create_file </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>mode_t <parameter>mode</parameter></paramdef>
   <paramdef>struct dentry * <parameter>parent</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>struct file_operations * <parameter>fops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      a pointer to a string containing the name of the file to create.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      the permission that the file should have
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
      a pointer to the parent dentry for this file.  This should be a
     directory dentry if set.  If this paramater is NULL, then the
     file will be created in the root of the debugfs filesystem.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
      a pointer to something that the caller will want to get to later
     on.  The inode.u.generic_ip pointer will point to this value on
     the <function>open</function> call.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fops</parameter></term>
   <listitem>
    <para>
      a pointer to a struct file_operations that should be used for
     this file.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This is the basic <quote>create a file</quote> function for debugfs.  It allows for a
   wide range of flexibility in createing a file, or a directory (if you
   want to create a directory, the <function>debugfs_create_dir</function> function is
   recommended to be used instead.)
   </para><para>

   This function will return a pointer to a dentry if it succeeds.  This
   pointer must be passed to the <function>debugfs_remove</function> function when the file is
   to be removed (no automatic cleanup happens if your module is unloaded,
   you are responsible here.)  If an error occurs, NULL will be returned.
   </para><para>

   If debugfs is not enabled in the kernel, the value -ENODEV will be
   returned.  It is not wise to check for this value, but rather, check for
   NULL or !NULL instead as to eliminate the need for #ifdef in the calling
   code.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This is the basic <quote>create a file</quote> function for debugfs.  It allows for a
   wide range of flexibility in createing a file, or a directory (if you
   want to create a directory, the <function>debugfs_create_dir</function> function is
   recommended to be used instead.)
   </para><para>

   This function will return a pointer to a dentry if it succeeds.  This
   pointer must be passed to the <function>debugfs_remove</function> function when the file is
   to be removed (no automatic cleanup happens if your module is unloaded,
   you are responsible here.)  If an error occurs, NULL will be returned.
   </para><para>

   If debugfs is not enabled in the kernel, the value -ENODEV will be
   returned.  It is not wise to check for this value, but rather, check for
   NULL or !NULL instead as to eliminate the need for #ifdef in the calling
   code.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-debugfs-create-dir">debugfs_create_dir</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>debugfs_create_dir</refname>
 <refpurpose>
      create a directory in the debugfs filesystem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>debugfs_create_dir </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct dentry * <parameter>parent</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      a pointer to a string containing the name of the directory to
     create.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
      a pointer to the parent dentry for this file.  This should be a
     directory dentry if set.  If this paramater is NULL, then the
     directory will be created in the root of the debugfs filesystem.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function creates a directory in debugfs with the given name.
   </para><para>

   This function will return a pointer to a dentry if it succeeds.  This
   pointer must be passed to the <function>debugfs_remove</function> function when the file is
   to be removed (no automatic cleanup happens if your module is unloaded,
   you are responsible here.)  If an error occurs, NULL will be returned.
   </para><para>

   If debugfs is not enabled in the kernel, the value -ENODEV will be
   returned.  It is not wise to check for this value, but rather, check for
   NULL or !NULL instead as to eliminate the need for #ifdef in the calling
   code.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function creates a directory in debugfs with the given name.
   </para><para>

   This function will return a pointer to a dentry if it succeeds.  This
   pointer must be passed to the <function>debugfs_remove</function> function when the file is
   to be removed (no automatic cleanup happens if your module is unloaded,
   you are responsible here.)  If an error occurs, NULL will be returned.
   </para><para>

   If debugfs is not enabled in the kernel, the value -ENODEV will be
   returned.  It is not wise to check for this value, but rather, check for
   NULL or !NULL instead as to eliminate the need for #ifdef in the calling
   code.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-debugfs-remove">debugfs_remove</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>debugfs_remove</refname>
 <refpurpose>
      removes a file or directory from the debugfs filesystem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>debugfs_remove </function></funcdef>
   <paramdef>struct dentry * <parameter>dentry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dentry</parameter></term>
   <listitem>
    <para>
      a pointer to a the dentry of the file or directory to be
     removed.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function removes a file or directory in debugfs that was previously
   created with a call to another debugfs function (like
   <function>debufs_create_file</function> or variants thereof.)
   </para><para>

   This function is required to be called in order for the file to be
   removed, no automatic cleanup of files will happen when a module is
   removed, you are responsible here.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function removes a file or directory in debugfs that was previously
   created with a call to another debugfs function (like
   <function>debufs_create_file</function> or variants thereof.)
   </para><para>

   This function is required to be called in order for the file to be
   removed, no automatic cleanup of files will happen when a module is
   removed, you are responsible here.
 </para>
</refsect1>
</refentry>

<!-- fs/debugfs/file.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-debugfs-create-u8">debugfs_create_u8</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>debugfs_create_u8</refname>
 <refpurpose>
   create a file in the debugfs filesystem that is used to read and write a unsigned 8 bit value.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>debugfs_create_u8 </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>mode_t <parameter>mode</parameter></paramdef>
   <paramdef>struct dentry * <parameter>parent</parameter></paramdef>
   <paramdef>u8 * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      a pointer to a string containing the name of the file to create.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      the permission that the file should have
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
      a pointer to the parent dentry for this file.  This should be a
     directory dentry if set.  If this paramater is NULL, then the
     file will be created in the root of the debugfs filesystem.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      a pointer to the variable that the file should read to and write
     from.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function creates a file in debugfs with the given name that
   contains the value of the variable <parameter>value</parameter>.  If the <parameter>mode</parameter> variable is so
   set, it can be read from, and written to.
   </para><para>

   This function will return a pointer to a dentry if it succeeds.  This
   pointer must be passed to the <function>debugfs_remove</function> function when the file is
   to be removed (no automatic cleanup happens if your module is unloaded,
   you are responsible here.)  If an error occurs, NULL will be returned.
   </para><para>

   If debugfs is not enabled in the kernel, the value -ENODEV will be
   returned.  It is not wise to check for this value, but rather, check for
   NULL or !NULL instead as to eliminate the need for #ifdef in the calling
   code.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function creates a file in debugfs with the given name that
   contains the value of the variable <parameter>value</parameter>.  If the <parameter>mode</parameter> variable is so
   set, it can be read from, and written to.
   </para><para>

   This function will return a pointer to a dentry if it succeeds.  This
   pointer must be passed to the <function>debugfs_remove</function> function when the file is
   to be removed (no automatic cleanup happens if your module is unloaded,
   you are responsible here.)  If an error occurs, NULL will be returned.
   </para><para>

   If debugfs is not enabled in the kernel, the value -ENODEV will be
   returned.  It is not wise to check for this value, but rather, check for
   NULL or !NULL instead as to eliminate the need for #ifdef in the calling
   code.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-debugfs-create-u16">debugfs_create_u16</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>debugfs_create_u16</refname>
 <refpurpose>
      create a file in the debugfs filesystem that is used to read and write a unsigned 8 bit value.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>debugfs_create_u16 </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>mode_t <parameter>mode</parameter></paramdef>
   <paramdef>struct dentry * <parameter>parent</parameter></paramdef>
   <paramdef>u16 * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      a pointer to a string containing the name of the file to create.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      the permission that the file should have
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
      a pointer to the parent dentry for this file.  This should be a
     directory dentry if set.  If this paramater is NULL, then the
     file will be created in the root of the debugfs filesystem.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      a pointer to the variable that the file should read to and write
     from.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function creates a file in debugfs with the given name that
   contains the value of the variable <parameter>value</parameter>.  If the <parameter>mode</parameter> variable is so
   set, it can be read from, and written to.
   </para><para>

   This function will return a pointer to a dentry if it succeeds.  This
   pointer must be passed to the <function>debugfs_remove</function> function when the file is
   to be removed (no automatic cleanup happens if your module is unloaded,
   you are responsible here.)  If an error occurs, NULL will be returned.
   </para><para>

   If debugfs is not enabled in the kernel, the value -ENODEV will be
   returned.  It is not wise to check for this value, but rather, check for
   NULL or !NULL instead as to eliminate the need for #ifdef in the calling
   code.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function creates a file in debugfs with the given name that
   contains the value of the variable <parameter>value</parameter>.  If the <parameter>mode</parameter> variable is so
   set, it can be read from, and written to.
   </para><para>

   This function will return a pointer to a dentry if it succeeds.  This
   pointer must be passed to the <function>debugfs_remove</function> function when the file is
   to be removed (no automatic cleanup happens if your module is unloaded,
   you are responsible here.)  If an error occurs, NULL will be returned.
   </para><para>

   If debugfs is not enabled in the kernel, the value -ENODEV will be
   returned.  It is not wise to check for this value, but rather, check for
   NULL or !NULL instead as to eliminate the need for #ifdef in the calling
   code.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-debugfs-create-u32">debugfs_create_u32</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>debugfs_create_u32</refname>
 <refpurpose>
      create a file in the debugfs filesystem that is used to read and write a unsigned 8 bit value.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>debugfs_create_u32 </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>mode_t <parameter>mode</parameter></paramdef>
   <paramdef>struct dentry * <parameter>parent</parameter></paramdef>
   <paramdef>u32 * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      a pointer to a string containing the name of the file to create.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      the permission that the file should have
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
      a pointer to the parent dentry for this file.  This should be a
     directory dentry if set.  If this paramater is NULL, then the
     file will be created in the root of the debugfs filesystem.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      a pointer to the variable that the file should read to and write
     from.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function creates a file in debugfs with the given name that
   contains the value of the variable <parameter>value</parameter>.  If the <parameter>mode</parameter> variable is so
   set, it can be read from, and written to.
   </para><para>

   This function will return a pointer to a dentry if it succeeds.  This
   pointer must be passed to the <function>debugfs_remove</function> function when the file is
   to be removed (no automatic cleanup happens if your module is unloaded,
   you are responsible here.)  If an error occurs, NULL will be returned.
   </para><para>

   If debugfs is not enabled in the kernel, the value -ENODEV will be
   returned.  It is not wise to check for this value, but rather, check for
   NULL or !NULL instead as to eliminate the need for #ifdef in the calling
   code.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function creates a file in debugfs with the given name that
   contains the value of the variable <parameter>value</parameter>.  If the <parameter>mode</parameter> variable is so
   set, it can be read from, and written to.
   </para><para>

   This function will return a pointer to a dentry if it succeeds.  This
   pointer must be passed to the <function>debugfs_remove</function> function when the file is
   to be removed (no automatic cleanup happens if your module is unloaded,
   you are responsible here.)  If an error occurs, NULL will be returned.
   </para><para>

   If debugfs is not enabled in the kernel, the value -ENODEV will be
   returned.  It is not wise to check for this value, but rather, check for
   NULL or !NULL instead as to eliminate the need for #ifdef in the calling
   code.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-debugfs-create-bool">debugfs_create_bool</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>debugfs_create_bool</refname>
 <refpurpose>
      create a file in the debugfs filesystem that is used to read and write a boolean value.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>debugfs_create_bool </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>mode_t <parameter>mode</parameter></paramdef>
   <paramdef>struct dentry * <parameter>parent</parameter></paramdef>
   <paramdef>u32 * <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      a pointer to a string containing the name of the file to create.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      the permission that the file should have
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
      a pointer to the parent dentry for this file.  This should be a
     directory dentry if set.  If this paramater is NULL, then the
     file will be created in the root of the debugfs filesystem.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
      a pointer to the variable that the file should read to and write
     from.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function creates a file in debugfs with the given name that
   contains the value of the variable <parameter>value</parameter>.  If the <parameter>mode</parameter> variable is so
   set, it can be read from, and written to.
   </para><para>

   This function will return a pointer to a dentry if it succeeds.  This
   pointer must be passed to the <function>debugfs_remove</function> function when the file is
   to be removed (no automatic cleanup happens if your module is unloaded,
   you are responsible here.)  If an error occurs, NULL will be returned.
   </para><para>

   If debugfs is not enabled in the kernel, the value -ENODEV will be
   returned.  It is not wise to check for this value, but rather, check for
   NULL or !NULL instead as to eliminate the need for #ifdef in the calling
   code.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function creates a file in debugfs with the given name that
   contains the value of the variable <parameter>value</parameter>.  If the <parameter>mode</parameter> variable is so
   set, it can be read from, and written to.
   </para><para>

   This function will return a pointer to a dentry if it succeeds.  This
   pointer must be passed to the <function>debugfs_remove</function> function when the file is
   to be removed (no automatic cleanup happens if your module is unloaded,
   you are responsible here.)  If an error occurs, NULL will be returned.
   </para><para>

   If debugfs is not enabled in the kernel, the value -ENODEV will be
   returned.  It is not wise to check for this value, but rather, check for
   NULL or !NULL instead as to eliminate the need for #ifdef in the calling
   code.
 </para>
</refsect1>
</refentry>

     </sect1>
  </chapter>

  <chapter id="vfs">
     <title>The Linux VFS</title>
     <sect1><title>The Directory Cache</title>
<!-- fs/dcache.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-invalidate">d_invalidate</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_invalidate</refname>
 <refpurpose>
   invalidate a dentry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>d_invalidate </function></funcdef>
   <paramdef>struct dentry * <parameter>dentry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dentry</parameter></term>
   <listitem>
    <para>
      dentry to invalidate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Try to invalidate the dentry if it turns out to be
   possible. If there are other dentries that can be
   reached through this one we can't delete it and we
   return -EBUSY. On success we return 0.
   </para><para>

   no dcache lock.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-shrink-dcache-sb">shrink_dcache_sb</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>shrink_dcache_sb</refname>
 <refpurpose>
      shrink dcache for a superblock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>shrink_dcache_sb </function></funcdef>
   <paramdef>struct super_block * <parameter>sb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sb</parameter></term>
   <listitem>
    <para>
      superblock
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Shrink the dcache for the specified super block. This
   is used to free the dcache before unmounting a file
   system
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-have-submounts">have_submounts</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>have_submounts</refname>
 <refpurpose>
      check for mounts over a dentry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>have_submounts </function></funcdef>
   <paramdef>struct dentry * <parameter>parent</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
      dentry to check.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Return true if the parent or its subdirectories contain
   a mount point
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-shrink-dcache-parent">shrink_dcache_parent</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>shrink_dcache_parent</refname>
 <refpurpose>
      prune dcache
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>shrink_dcache_parent </function></funcdef>
   <paramdef>struct dentry * <parameter>parent</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
      parent of entries to prune
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Prune the dcache to remove unused children of the parent dentry.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-alloc">d_alloc</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_alloc</refname>
 <refpurpose>
     	allocate a dcache entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>d_alloc </function></funcdef>
   <paramdef>struct dentry * <parameter>parent</parameter></paramdef>
   <paramdef>const struct qstr * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
      parent of entry to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      qstr of the name
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocates a dentry. It returns <constant>NULL</constant> if there is insufficient memory
   available. On a success the dentry is returned. The name passed in is
   copied and the copy passed in may be reused after this call.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-instantiate">d_instantiate</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_instantiate</refname>
 <refpurpose>
      fill in inode information for a dentry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>d_instantiate </function></funcdef>
   <paramdef>struct dentry * <parameter>entry</parameter></paramdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
      dentry to complete
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      inode to attach to this dentry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Fill in inode information in the entry.
   </para><para>

   This turns negative dentries into productive full members
   of society.
   </para><para>

   NOTE! This assumes that the inode count has been incremented
   (or otherwise set) by the caller to indicate that it is now
   in use by the dcache.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-instantiate-unique">d_instantiate_unique</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_instantiate_unique</refname>
 <refpurpose>
      instantiate a non-aliased dentry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>d_instantiate_unique </function></funcdef>
   <paramdef>struct dentry * <parameter>entry</parameter></paramdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
      dentry to instantiate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      inode to attach to this dentry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Fill in inode information in the entry. On success, it returns NULL.
   If an unhashed alias of <quote>entry</quote> already exists, then we return the
   aliased dentry instead.
   </para><para>

   Note that in order to avoid conflicts with <function>rename</function> etc, the caller
   had better be holding the parent directory semaphore.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-alloc-root">d_alloc_root</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_alloc_root</refname>
 <refpurpose>
      allocate root dentry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>d_alloc_root </function></funcdef>
   <paramdef>struct inode * <parameter>root_inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>root_inode</parameter></term>
   <listitem>
    <para>
      inode to allocate the root for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocate a root (<quote>/</quote>) dentry for the inode given. The inode is
   instantiated and returned. <constant>NULL</constant> is returned if there is insufficient
   memory or the inode passed is <constant>NULL</constant>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-alloc-anon">d_alloc_anon</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_alloc_anon</refname>
 <refpurpose>
      allocate an anonymous dentry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>d_alloc_anon </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      inode to allocate the dentry for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This is similar to d_alloc_root.  It is used by filesystems when
   creating a dentry for a given inode, often in the process of 
   mapping a filehandle to a dentry.  The returned dentry may be
   anonymous, or may have a full name (if the inode was already
   in the cache).  The file system may need to make further
   efforts to connect this dentry into the dcache properly.
   </para><para>

   When called on a directory inode, we must ensure that
   the inode only ever has one dentry.  If a dentry is
   found, that is returned instead of allocating a new one.
   </para><para>

   On successful return, the reference to the inode has been transferred
   to the dentry.  If <constant>NULL</constant> is returned (indicating kmalloc failure),
   the reference on the inode has not been released.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-splice-alias">d_splice_alias</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_splice_alias</refname>
 <refpurpose>
      splice a disconnected dentry into the tree if one exists
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>d_splice_alias </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
   <paramdef>struct dentry * <parameter>dentry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
       the inode which may have a disconnected dentry
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dentry</parameter></term>
   <listitem>
    <para>
      a negative dentry which we want to point to the inode.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If inode is a directory and has a 'disconnected' dentry (i.e. IS_ROOT and
   DCACHE_DISCONNECTED), then d_move that in place of the given dentry
   and return it, else simply d_add the inode to the dentry and return NULL.
   </para><para>

   This is needed in the lookup routine of any filesystem that is exportable
   (via knfsd) so that we can build dcache paths to directories effectively.
   </para><para>

   If a dentry was found and moved, then it is returned.  Otherwise NULL
   is returned.  This matches the expected return value of -&gt;lookup.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-lookup">d_lookup</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_lookup</refname>
 <refpurpose>
      search for a dentry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>d_lookup </function></funcdef>
   <paramdef>struct dentry * <parameter>parent</parameter></paramdef>
   <paramdef>struct qstr * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
      parent dentry
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      qstr of name we wish to find
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the children of the parent dentry for the name in question. If
   the dentry is found its reference count is incremented and the dentry
   is returned. The caller must use d_put to free the entry when it has
   finished using it. <constant>NULL</constant> is returned on failure.
   </para><para>

   __d_lookup is dcache_lock free. The hash list is protected using RCU.
   Memory barriers are used while updating and doing lockless traversal. 
   To avoid races with d_move while rename is happening, d_lock is used.
   </para><para>

   Overflows in <function>memcmp</function>, while d_move, are avoided by keeping the length
   and name pointer in one structure pointed by d_qstr.
   </para><para>

   <function>rcu_read_lock</function> and <function>rcu_read_unlock</function> are used to disable preemption while
   lookup is going on.
   </para><para>

   dentry_unused list is not updated even if lookup finds the required dentry
   in there. It is updated in places such as prune_dcache, shrink_dcache_sb,
   select_parent and __dget_locked. This laziness saves lookup from dcache_lock
   acquisition.
   </para><para>

   <function>d_lookup</function> is protected against the concurrent renames in some unrelated
   directory using the seqlockt_t rename_lock.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-validate">d_validate</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_validate</refname>
 <refpurpose>
      verify dentry provided from insecure source
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>d_validate </function></funcdef>
   <paramdef>struct dentry * <parameter>dentry</parameter></paramdef>
   <paramdef>struct dentry * <parameter>dparent</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dentry</parameter></term>
   <listitem>
    <para>
      The dentry alleged to be valid child of <parameter>dparent</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dparent</parameter></term>
   <listitem>
    <para>
      The parent dentry (known to be valid)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   An insecure source has sent us a dentry, here we verify it and <function>dget</function> it.
   This is used by ncpfs in its readdir implementation.
   Zero is returned in the dentry is invalid.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-delete">d_delete</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_delete</refname>
 <refpurpose>
      delete a dentry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>d_delete </function></funcdef>
   <paramdef>struct dentry * <parameter>dentry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dentry</parameter></term>
   <listitem>
    <para>
      The dentry to delete
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Turn the dentry into a negative dentry if possible, otherwise
   remove it from the hash queues so it can be deleted later
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-rehash">d_rehash</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_rehash</refname>
 <refpurpose>
      add an entry back to the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>d_rehash </function></funcdef>
   <paramdef>struct dentry * <parameter>entry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
      dentry to add to the hash
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Adds a dentry to the hash according to its name.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-move">d_move</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_move</refname>
 <refpurpose>
      move a dentry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>d_move </function></funcdef>
   <paramdef>struct dentry * <parameter>dentry</parameter></paramdef>
   <paramdef>struct dentry * <parameter>target</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dentry</parameter></term>
   <listitem>
    <para>
      entry to move
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>target</parameter></term>
   <listitem>
    <para>
      new dentry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Update the dcache to reflect the move of a file name. Negative
   dcache entries should not be moved in this way.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-find-inode-number">find_inode_number</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>find_inode_number</refname>
 <refpurpose>
      check for dentry with name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ino_t <function>find_inode_number </function></funcdef>
   <paramdef>struct dentry * <parameter>dir</parameter></paramdef>
   <paramdef>struct qstr * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dir</parameter></term>
   <listitem>
    <para>
      directory to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      Name to find.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Check whether a dentry already exists for the given name,
   and return the inode number if it has an inode. Otherwise
   0 is returned.
   </para><para>

   This routine is used to post-process directory listings for
   filesystems using synthetic inode numbers, and is necessary
   to keep <function>getcwd</function> working.
 </para>
</refsect1>
</refentry>

<!-- include/linux/dcache.h -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API---d-drop">__d_drop</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__d_drop</refname>
 <refpurpose>
   drop a dentry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__d_drop </function></funcdef>
   <paramdef>struct dentry * <parameter>dentry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dentry</parameter></term>
   <listitem>
    <para>
      dentry to drop
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>d_drop</function> unhashes the entry from the parent
   dentry hashes, so that it won't be found through
   a VFS lookup any more. Note that this is different
   from deleting the dentry - d_delete will try to
   mark the dentry negative if possible, giving a
   successful _negative_ lookup, while d_drop will
   just make the cache lookup fail.
   </para><para>

   <function>d_drop</function> is used mainly for stuff that wants
   to invalidate a dentry for some reason (NFS
   timeouts or autofs deletes).
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-add">d_add</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_add</refname>
 <refpurpose>
      add dentry to hash queues
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>d_add </function></funcdef>
   <paramdef>struct dentry * <parameter>entry</parameter></paramdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
      dentry to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      The inode to attach to this dentry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This adds the entry to the hash queues and initializes <parameter>inode</parameter>.
   The entry was actually filled in earlier during <function>d_alloc</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-add-unique">d_add_unique</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_add_unique</refname>
 <refpurpose>
      add dentry to hash queues without aliasing
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>d_add_unique </function></funcdef>
   <paramdef>struct dentry * <parameter>entry</parameter></paramdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
      dentry to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      The inode to attach to this dentry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This adds the entry to the hash queues and initializes <parameter>inode</parameter>.
   The entry was actually filled in earlier during <function>d_alloc</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dget">dget</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dget</refname>
 <refpurpose>
     	get a reference to a dentry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dentry * <function>dget </function></funcdef>
   <paramdef>struct dentry * <parameter>dentry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dentry</parameter></term>
   <listitem>
    <para>
      dentry to get a reference to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Given a dentry or <constant>NULL</constant> pointer increment the reference count
   if appropriate and return the dentry. A dentry will not be 
   destroyed when it has references. <function>dget</function> should never be
   called for dentries with zero reference counter. For these cases
   (preferably none, functions in dcache.c are sufficient for normal
   needs and they take necessary precautions) you should hold dcache_lock
   and call <function>dget_locked</function> instead of <function>dget</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-d-unhashed">d_unhashed</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>d_unhashed</refname>
 <refpurpose>
     	is dentry hashed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>d_unhashed </function></funcdef>
   <paramdef>struct dentry * <parameter>dentry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dentry</parameter></term>
   <listitem>
    <para>
      entry to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns true if the dentry passed is not currently hashed.
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Inode Handling</title>
<!-- fs/inode.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-clear-inode">clear_inode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>clear_inode</refname>
 <refpurpose>
   clear an inode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>clear_inode </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      inode to clear
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This is called by the filesystem to tell us
   that the inode is no longer useful. We just
   terminate it with extreme prejudice.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-invalidate-inodes">invalidate_inodes</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>invalidate_inodes</refname>
 <refpurpose>
      discard the inodes on a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>invalidate_inodes </function></funcdef>
   <paramdef>struct super_block * <parameter>sb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sb</parameter></term>
   <listitem>
    <para>
      superblock
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Discard all of the inodes for a given superblock. If the discard
   fails because there are busy inodes then a non zero value is returned.
   If the discard is successful all the inodes have been discarded.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-new-inode">new_inode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>new_inode</refname>
 <refpurpose>
      obtain an inode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct inode * <function>new_inode </function></funcdef>
   <paramdef>struct super_block * <parameter>sb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sb</parameter></term>
   <listitem>
    <para>
      superblock
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocates a new inode for given superblock.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-iunique">iunique</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>iunique</refname>
 <refpurpose>
      get a unique inode number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ino_t <function>iunique </function></funcdef>
   <paramdef>struct super_block * <parameter>sb</parameter></paramdef>
   <paramdef>ino_t <parameter>max_reserved</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sb</parameter></term>
   <listitem>
    <para>
      superblock
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_reserved</parameter></term>
   <listitem>
    <para>
      highest reserved inode number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Obtain an inode number that is unique on the system for a given
   superblock. This is used by file systems that have no natural
   permanent inode numbering system. An inode number is returned that
   is higher than the reserved limit but unique.
 </para>
</refsect1>
<refsect1>
 <title>BUGS</title>
 <para>
   With a large number of inodes live on the file system this function
   currently becomes quite slow.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-ilookup5">ilookup5</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>ilookup5</refname>
 <refpurpose>
      search for an inode in the inode cache
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct inode * <function>ilookup5 </function></funcdef>
   <paramdef>struct super_block * <parameter>sb</parameter></paramdef>
   <paramdef>unsigned long <parameter>hashval</parameter></paramdef>
   <paramdef>int (*<parameter>test</parameter>)
     <funcparams>struct inode *, void *</funcparams></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sb</parameter></term>
   <listitem>
    <para>
     		super block of file system to search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hashval</parameter></term>
   <listitem>
    <para>
     	hash value (usually inode number) to search for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>test</parameter></term>
   <listitem>
    <para>
     	callback used for comparisons between inodes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     	opaque data pointer to pass to <parameter>test</parameter>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>ilookup5</function> uses <function>ifind</function> to search for the inode specified by <parameter>hashval</parameter> and
   <parameter>data</parameter> in the inode cache. This is a generalized version of <function>ilookup</function> for
   file systems where the inode number is not sufficient for unique
   identification of an inode.
   </para><para>

   If the inode is in the cache, the inode is returned with an incremented
   reference count.
   </para><para>

   Otherwise NULL is returned.
   </para><para>

   Note, <parameter>test</parameter> is called with the inode_lock held, so can't sleep.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-ilookup">ilookup</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>ilookup</refname>
 <refpurpose>
      search for an inode in the inode cache
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct inode * <function>ilookup </function></funcdef>
   <paramdef>struct super_block * <parameter>sb</parameter></paramdef>
   <paramdef>unsigned long <parameter>ino</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sb</parameter></term>
   <listitem>
    <para>
     		super block of file system to search
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ino</parameter></term>
   <listitem>
    <para>
     	inode number to search for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>ilookup</function> uses <function>ifind_fast</function> to search for the inode <parameter>ino</parameter> in the inode cache.
   This is for file systems where the inode number is sufficient for unique
   identification of an inode.
   </para><para>

   If the inode is in the cache, the inode is returned with an incremented
   reference count.
   </para><para>

   Otherwise NULL is returned.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-iget5-locked">iget5_locked</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>iget5_locked</refname>
 <refpurpose>
      obtain an inode from a mounted file system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct inode * <function>iget5_locked </function></funcdef>
   <paramdef>struct super_block * <parameter>sb</parameter></paramdef>
   <paramdef>unsigned long <parameter>hashval</parameter></paramdef>
   <paramdef>int (*<parameter>test</parameter>)
     <funcparams>struct inode *, void *</funcparams></paramdef>
   <paramdef>int (*<parameter>set</parameter>)
     <funcparams>struct inode *, void *</funcparams></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sb</parameter></term>
   <listitem>
    <para>
     		super block of file system
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hashval</parameter></term>
   <listitem>
    <para>
     	hash value (usually inode number) to get
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>test</parameter></term>
   <listitem>
    <para>
     	callback used for comparisons between inodes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>set</parameter></term>
   <listitem>
    <para>
     	callback used to initialize a new struct inode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     	opaque data pointer to pass to <parameter>test</parameter> and <parameter>set</parameter>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This is <function>iget</function> without the <function>read_inode</function> portion of <function>get_new_inode</function>.
   </para><para>

   <function>iget5_locked</function> uses <function>ifind</function> to search for the inode specified by <parameter>hashval</parameter>
   and <parameter>data</parameter> in the inode cache and if present it is returned with an increased
   reference count. This is a generalized version of <function>iget_locked</function> for file
   systems where the inode number is not sufficient for unique identification
   of an inode.
   </para><para>

   If the inode is not in cache, <function>get_new_inode</function> is called to allocate a new
   inode and this is returned locked, hashed, and with the I_NEW flag set. The
   file system gets to fill it in before unlocking it via <function>unlock_new_inode</function>.
   </para><para>

   Note both <parameter>test</parameter> and <parameter>set</parameter> are called with the inode_lock held, so can't sleep.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-iget-locked">iget_locked</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>iget_locked</refname>
 <refpurpose>
      obtain an inode from a mounted file system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct inode * <function>iget_locked </function></funcdef>
   <paramdef>struct super_block * <parameter>sb</parameter></paramdef>
   <paramdef>unsigned long <parameter>ino</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sb</parameter></term>
   <listitem>
    <para>
     		super block of file system
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ino</parameter></term>
   <listitem>
    <para>
     	inode number to get
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This is <function>iget</function> without the <function>read_inode</function> portion of <function>get_new_inode_fast</function>.
   </para><para>

   <function>iget_locked</function> uses <function>ifind_fast</function> to search for the inode specified by <parameter>ino</parameter> in
   the inode cache and if present it is returned with an increased reference
   count. This is for file systems where the inode number is sufficient for
   unique identification of an inode.
   </para><para>

   If the inode is not in cache, <function>get_new_inode_fast</function> is called to allocate a
   new inode and this is returned locked, hashed, and with the I_NEW flag set.
   The file system gets to fill it in before unlocking it via
   <function>unlock_new_inode</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---insert-inode-hash">__insert_inode_hash</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__insert_inode_hash</refname>
 <refpurpose>
      hash an inode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__insert_inode_hash </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
   <paramdef>unsigned long <parameter>hashval</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      unhashed inode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hashval</parameter></term>
   <listitem>
    <para>
      unsigned long value used to locate this object in the
     inode_hashtable.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Add an inode to the inode hash for this superblock.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-remove-inode-hash">remove_inode_hash</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>remove_inode_hash</refname>
 <refpurpose>
      remove an inode from the hash
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>remove_inode_hash </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      inode to unhash
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Remove an inode from the superblock.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-iput">iput</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>iput</refname>
 <refpurpose>
      put an inode 
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>iput </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      inode to put
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Puts an inode, dropping its usage count. If the inode use count hits
   zero the inode is also then freed and may be destroyed.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-bmap">bmap</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>bmap</refname>
 <refpurpose>
      find a block number in a file
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>sector_t <function>bmap </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
   <paramdef>sector_t <parameter>block</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      inode of file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>block</parameter></term>
   <listitem>
    <para>
      block to find
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns the block number on the device holding the inode that
   is the disk block number for the block of the file requested.
   That is, asked for block 4 of inode 1 the function will return the
   disk block relative to the disk start that holds that block of the 
   file.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-update-atime">update_atime</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>update_atime</refname>
 <refpurpose>
     	update the access time
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>update_atime </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      inode accessed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Update the accessed time on an inode and mark it for writeback.
   This function automatically handles read only file systems and media,
   as well as the <quote>noatime</quote> flag and inode specific <quote>noatime</quote> markers.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-inode-update-time">inode_update_time</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>inode_update_time</refname>
 <refpurpose>
     	update mtime and ctime time
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>inode_update_time </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
   <paramdef>int <parameter>ctime_too</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      inode accessed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ctime_too</parameter></term>
   <listitem>
    <para>
      update ctime too
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Update the mtime time on an inode and mark it for writeback.
   When ctime_too is specified update the ctime too.
 </para>
</refsect1>
</refentry>

<!-- fs/bad_inode.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-make-bad-inode">make_bad_inode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>make_bad_inode</refname>
 <refpurpose>
   mark an inode bad due to an I/O error
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>make_bad_inode </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      Inode to mark bad
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   When an inode cannot be read due to a media or remote network
   failure this function makes the inode <quote>bad</quote> and causes I/O operations
   on it to fail from this point on.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-is-bad-inode">is_bad_inode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>is_bad_inode</refname>
 <refpurpose>
      is an inode errored
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>is_bad_inode </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      inode to test
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns true if the inode in question has been marked as bad.
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Registration and Superblocks</title>
<!-- fs/super.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-deactivate-super">deactivate_super</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>deactivate_super</refname>
 <refpurpose>
  	drop an active reference to superblock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>deactivate_super </function></funcdef>
   <paramdef>struct super_block * <parameter>s</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>s</parameter></term>
   <listitem>
    <para>
      superblock to deactivate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Drops an active reference to superblock, acquiring a temprory one if
   there is no active references left.  In that case we lock superblock,
   tell fs driver to shut it down and drop the temporary reference we
   had just acquired.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-generic-shutdown-super">generic_shutdown_super</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>generic_shutdown_super</refname>
 <refpurpose>
     	common helper for -><function>kill_sb</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>generic_shutdown_super </function></funcdef>
   <paramdef>struct super_block * <parameter>sb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sb</parameter></term>
   <listitem>
    <para>
      superblock to kill
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>generic_shutdown_super</function> does all fs-independent work on superblock
   shutdown.  Typical -&gt;<function>kill_sb</function> should pick all fs-specific objects
   that need destruction out of superblock, call <function>generic_shutdown_super</function>
   and release aforementioned objects.  Note: dentries and inodes _are_
   taken care of and do not need specific handling.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sget">sget</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sget</refname>
 <refpurpose>
     	find or create a superblock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct super_block * <function>sget </function></funcdef>
   <paramdef>struct file_system_type * <parameter>type</parameter></paramdef>
   <paramdef>int (*<parameter>test</parameter>)
     <funcparams>struct super_block *,void *</funcparams></paramdef>
   <paramdef>int (*<parameter>set</parameter>)
     <funcparams>struct super_block *,void *</funcparams></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     	filesystem type superblock should belong to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>test</parameter></term>
   <listitem>
    <para>
     	comparison callback
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>set</parameter></term>
   <listitem>
    <para>
     	setup callback
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     	argument to each of them
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-get-super">get_super</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>get_super</refname>
 <refpurpose>
      get the superblock of a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct super_block * <function>get_super </function></funcdef>
   <paramdef>struct block_device * <parameter>bdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bdev</parameter></term>
   <listitem>
    <para>
      device to get the superblock for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Scans the superblock list and finds the superblock of the file system
   mounted on the device given. <constant>NULL</constant> is returned if no match is found.
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>File Locks</title>
<!-- fs/locks.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-posix-lock-file">posix_lock_file</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>posix_lock_file</refname>
 <refpurpose>
   Apply a POSIX-style lock to a file
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>posix_lock_file </function></funcdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>struct file_lock * <parameter>fl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      The file to apply the lock to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fl</parameter></term>
   <listitem>
    <para>
      The lock to be applied
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Add a POSIX style lock to a file.
   We merge adjacent &amp; overlapping locks whenever possible.
   POSIX locks are sorted by owner task, then by starting address
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-posix-lock-file-wait">posix_lock_file_wait</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>posix_lock_file_wait</refname>
 <refpurpose>
      Apply a POSIX-style lock to a file
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>posix_lock_file_wait </function></funcdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>struct file_lock * <parameter>fl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      The file to apply the lock to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fl</parameter></term>
   <listitem>
    <para>
      The lock to be applied
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Add a POSIX style lock to a file.
   We merge adjacent &amp; overlapping locks whenever possible.
   POSIX locks are sorted by owner task, then by starting address
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-locks-mandatory-area">locks_mandatory_area</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>locks_mandatory_area</refname>
 <refpurpose>
      Check for a conflicting lock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>locks_mandatory_area </function></funcdef>
   <paramdef>int <parameter>read_write</parameter></paramdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>loff_t <parameter>offset</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>read_write</parameter></term>
   <listitem>
    <para>
      <constant>FLOCK_VERIFY_WRITE</constant> for exclusive access, <constant>FLOCK_VERIFY_READ</constant>
     for shared
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
           the file to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
            how the file was opened (if it was)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
          start of area to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
           length of area to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the inode's list of locks to find any POSIX locks which conflict.
   This function is called from <function>rw_verify_area</function> and
   <function>locks_verify_truncate</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---break-lease">__break_lease</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__break_lease</refname>
 <refpurpose>
     	revoke all outstanding leases on file
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__break_lease </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
   <paramdef>unsigned int <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      the inode of the file to return
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      the open mode (read or write)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   break_lease (inlined for speed) has checked there already
   is a lease on this file.  Leases are broken on a call to <function>open</function>
   or <function>truncate</function>.  This function can sleep unless you
   specified <constant>O_NONBLOCK</constant> to your <function>open</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-lease-get-mtime">lease_get_mtime</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>lease_get_mtime</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>lease_get_mtime </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
   <paramdef>struct timespec * <parameter>time</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      the inode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>time</parameter></term>
   <listitem>
    <para>
       pointer to a timespec which will contain the last modified time
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This is to force NFS clients to flush their caches for files with
   exclusive leases.  The justification is that if someone has an
   exclusive lease, then they could be modifiying it.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-flock-lock-file-wait">flock_lock_file_wait</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>flock_lock_file_wait</refname>
 <refpurpose>
      Apply a FLOCK-style lock to a file
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>flock_lock_file_wait </function></funcdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>struct file_lock * <parameter>fl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      The file to apply the lock to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fl</parameter></term>
   <listitem>
    <para>
      The lock to be applied
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Add a FLOCK style lock to a file.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-posix-block-lock">posix_block_lock</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>posix_block_lock</refname>
 <refpurpose>
      blocks waiting for a file lock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>posix_block_lock </function></funcdef>
   <paramdef>struct file_lock * <parameter>blocker</parameter></paramdef>
   <paramdef>struct file_lock * <parameter>waiter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>blocker</parameter></term>
   <listitem>
    <para>
      the lock which is blocking
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>waiter</parameter></term>
   <listitem>
    <para>
      the lock which conflicts and has to wait
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   lockd needs to block waiting for locks.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-posix-unblock-lock">posix_unblock_lock</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>posix_unblock_lock</refname>
 <refpurpose>
      stop waiting for a file lock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>posix_unblock_lock </function></funcdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>struct file_lock * <parameter>waiter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
        how the file was opened
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>waiter</parameter></term>
   <listitem>
    <para>
      the lock which was waiting
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   lockd needs to block waiting for locks.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-lock-may-read">lock_may_read</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>lock_may_read</refname>
 <refpurpose>
      checks that the region is free of locks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>lock_may_read </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
   <paramdef>loff_t <parameter>start</parameter></paramdef>
   <paramdef>unsigned long <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      the inode that is being read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
      the first byte to read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
      the number of bytes to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Emulates Windows locking requirements.  Whole-file
   mandatory locks (share modes) can prohibit a read and
   byte-range POSIX locks can prohibit a read if they overlap.
   </para><para>

   N.B. this function is only ever called
   from knfsd and ownership of locks is never checked.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-lock-may-write">lock_may_write</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>lock_may_write</refname>
 <refpurpose>
      checks that the region is free of locks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>lock_may_write </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
   <paramdef>loff_t <parameter>start</parameter></paramdef>
   <paramdef>unsigned long <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      the inode that is being written
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
      the first byte to write
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
      the number of bytes to write
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Emulates Windows locking requirements.  Whole-file
   mandatory locks (share modes) can prohibit a write and
   byte-range POSIX locks can prohibit a write if they overlap.
   </para><para>

   N.B. this function is only ever called
   from knfsd and ownership of locks is never checked.
 </para>
</refsect1>
</refentry>

<!-- fs/locks.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-locks-mandatory-locked">locks_mandatory_locked</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>locks_mandatory_locked</refname>
 <refpurpose>
   Check for an active lock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>locks_mandatory_locked </function></funcdef>
   <paramdef>struct inode * <parameter>inode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>inode</parameter></term>
   <listitem>
    <para>
      the file to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Searches the inode's list of locks to find any POSIX locks which conflict.
   This function is called from <function>locks_verify_locked</function> only.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fcntl-getlease">fcntl_getlease</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fcntl_getlease</refname>
 <refpurpose>
      Enquire what lease is currently active
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fcntl_getlease </function></funcdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      the file
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The value returned by this function will be one of
   (if no lease break is pending):
   </para><para>

   <constant>F_RDLCK</constant> to indicate a shared lease is held.
   </para><para>

   <constant>F_WRLCK</constant> to indicate an exclusive lease is held.
   </para><para>

   <constant>F_UNLCK</constant> to indicate no lease is held.
   </para><para>

   (if a lease break is pending):
   </para><para>

   <constant>F_RDLCK</constant> to indicate an exclusive lease needs to be
   changed to a shared lease (or removed).
   </para><para>

   <constant>F_UNLCK</constant> to indicate the lease needs to be removed.
 </para>
</refsect1>
<refsect1>
 <title>XXX</title>
 <para>
    sfr &amp; willy disagree over whether F_INPROGRESS
   should be returned to userspace.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---setlease">__setlease</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__setlease</refname>
 <refpurpose>
     	sets a lease on an open file
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__setlease </function></funcdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>long <parameter>arg</parameter></paramdef>
   <paramdef>struct file_lock ** <parameter>flp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      file pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arg</parameter></term>
   <listitem>
    <para>
      type of lease to obtain
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flp</parameter></term>
   <listitem>
    <para>
      input - file_lock to use, output - file_lock inserted
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The (input) flp-&gt;fl_lmops-&gt;fl_break function is required
   by <function>break_lease</function>.
   </para><para>

   Called with kernel lock held.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fcntl-setlease">fcntl_setlease</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fcntl_setlease</refname>
 <refpurpose>
     	sets a lease on an open file
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fcntl_setlease </function></funcdef>
   <paramdef>unsigned int <parameter>fd</parameter></paramdef>
   <paramdef>struct file * <parameter>filp</parameter></paramdef>
   <paramdef>long <parameter>arg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fd</parameter></term>
   <listitem>
    <para>
      open file descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filp</parameter></term>
   <listitem>
    <para>
      file pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arg</parameter></term>
   <listitem>
    <para>
      type of lease to obtain
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Call this fcntl to establish a lease on the file.
   Note that you also need to call <constant>F_SETSIG</constant> to
   receive a signal when the lease is broken.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sys-flock">sys_flock</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sys_flock</refname>
 <refpurpose>
      <function>flock</function> system call.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>asmlinkage long <function>sys_flock </function></funcdef>
   <paramdef>unsigned int <parameter>fd</parameter></paramdef>
   <paramdef>unsigned int <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fd</parameter></term>
   <listitem>
    <para>
      the file descriptor to lock.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
      the type of lock to apply.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Apply a <constant>FL_FLOCK</constant> style lock to an open file descriptor.
   The <parameter>cmd</parameter> can be one of
   </para><para>

   <constant>LOCK_SH</constant> -- a shared lock.
   </para><para>

   <constant>LOCK_EX</constant> -- an exclusive lock.
   </para><para>

   <constant>LOCK_UN</constant> -- remove an existing lock.
   </para><para>

   <constant>LOCK_MAND</constant> -- a `mandatory' flock.  This exists to emulate Windows Share Modes.
   </para><para>

   <constant>LOCK_MAND</constant> can be combined with <constant>LOCK_READ</constant> or <constant>LOCK_WRITE</constant> to allow other
   processes read and write access respectively.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-get-locks-status">get_locks_status</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>get_locks_status</refname>
 <refpurpose>
     	reports lock usage in /proc/locks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>get_locks_status </function></funcdef>
   <paramdef>char * <parameter>buffer</parameter></paramdef>
   <paramdef>char ** <parameter>start</parameter></paramdef>
   <paramdef>off_t <parameter>offset</parameter></paramdef>
   <paramdef>int <parameter>length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
      address in userspace to write into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
      ?
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
      how far we are through the buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      how much to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

     </sect1>
  </chapter>

  <chapter id="netcore">
     <title>Linux Networking</title>
     <sect1><title>Socket Buffer Functions</title>
<!-- include/linux/skbuff.h -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-struct-sk-buff">struct sk_buff</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>struct sk_buff</refname>
 <refpurpose>
   socket buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct sk_buff {
  struct sk_buff * next;
  struct sk_buff * prev;
  struct sk_buff_head * list;
  struct sock * sk;
  struct timeval stamp;
  struct net_device * dev;
  struct net_device * input_dev;
  struct net_device * real_dev;
  union h;
  union nh;
  union mac;
  struct dst_entry * dst;
  char cb[40];
  unsigned int len;
  unsigned int data_len;
  unsigned int mac_len;
  unsigned int csum;
  unsigned char cloned;
  unsigned char pkt_type;
  unsigned char ip_summed;
  __u32 priority;
  unsigned short protocol;
  unsigned short security;
  void (* destructor) (struct sk_buff *skb);
#ifdef CONFIG_NETFILTER
  unsigned long nfmark;
  __u32 nfcache;
  __u32 nfctinfo;
  struct nf_conntrack * nfct;
#ifdef CONFIG_NETFILTER_DEBUG
  unsigned int nf_debug;
#endif
#ifdef CONFIG_BRIDGE_NETFILTER
  struct nf_bridge_info * nf_bridge;
#endif
#endif
#if defined(CONFIG_HIPPI)
  union private;
#endif
#ifdef CONFIG_NET_SCHED
  __u32 tc_index;
#ifdef CONFIG_NET_CLS_ACT
#endif
#endif
  unsigned int truesize;
  atomic_t users;
  unsigned char * head;
  unsigned char * data;
  unsigned char * tail;
  unsigned char * end;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>next</term>
      <listitem><para>
 Next buffer in list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>prev</term>
      <listitem><para>
 Previous buffer in list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>list</term>
      <listitem><para>
 List we are on
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sk</term>
      <listitem><para>
 Socket we are owned by
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>stamp</term>
      <listitem><para>
 Time we arrived
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
 Device we arrived on/are leaving by
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>input_dev</term>
      <listitem><para>
 Device we arrived on
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>real_dev</term>
      <listitem><para>
 The real device we are using
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>h</term>
      <listitem><para>
 Transport layer header
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>nh</term>
      <listitem><para>
 Network layer header
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mac</term>
      <listitem><para>
 Link layer header
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dst</term>
      <listitem><para>
 FIXME: Describe this field
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cb[40]</term>
      <listitem><para>
 Control buffer. Free for use by every layer. Put private vars here
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>len</term>
      <listitem><para>
 Length of actual data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>data_len</term>
      <listitem><para>
 Data length
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mac_len</term>
      <listitem><para>
 Length of link layer header
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>csum</term>
      <listitem><para>
 Checksum
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cloned</term>
      <listitem><para>
 Head may be cloned (check refcnt to be sure)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pkt_type</term>
      <listitem><para>
 Packet class
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ip_summed</term>
      <listitem><para>
 Driver fed us an IP checksum
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>priority</term>
      <listitem><para>
 Packet queueing priority
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>protocol</term>
      <listitem><para>
 Packet protocol from driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>security</term>
      <listitem><para>
 Security level of packet
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>destructor</term>
      <listitem><para>
 Destruct function
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>nfmark</term>
      <listitem><para>
 Can be used for communication between hooks
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>nfcache</term>
      <listitem><para>
 Cache info
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>nfctinfo</term>
      <listitem><para>
 Relationship of this skb to the connection
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>nfct</term>
      <listitem><para>
 Associated connection, if any
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>nf_debug</term>
      <listitem><para>
 Netfilter debugging
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>nf_bridge</term>
      <listitem><para>
 Saved data about a bridged frame - see br_netfilter.c
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>private</term>
      <listitem><para>
 Data which is private to the HIPPI implementation
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tc_index</term>
      <listitem><para>
 Traffic control index
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>truesize</term>
      <listitem><para>
 Buffer size 
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>users</term>
      <listitem><para>
 User count - see {datagram,tcp}.c
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>head</term>
      <listitem><para>
 Head of buffer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>data</term>
      <listitem><para>
 Data head pointer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tail</term>
      <listitem><para>
 Tail pointer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>end</term>
      <listitem><para>
 End pointer
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-queue-empty">skb_queue_empty</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_queue_empty</refname>
 <refpurpose>
      check if a queue is empty
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_queue_empty </function></funcdef>
   <paramdef>const struct sk_buff_head * <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      queue head
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns true if the queue is empty, false otherwise.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-get">skb_get</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_get</refname>
 <refpurpose>
      reference buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_get </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to reference
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Makes another reference to a socket buffer and returns a pointer
   to the buffer.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-kfree-skb">kfree_skb</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>kfree_skb</refname>
 <refpurpose>
      free an sk_buff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>kfree_skb </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Drop a reference to the buffer and free it if the usage count has
   hit zero.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-cloned">skb_cloned</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_cloned</refname>
 <refpurpose>
      is the buffer a clone
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_cloned </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns true if the buffer was generated with <function>skb_clone</function> and is
   one of multiple shared copies of the buffer. Cloned buffers are
   shared data so must not be written to under normal circumstances.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-shared">skb_shared</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_shared</refname>
 <refpurpose>
      is the buffer shared
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_shared </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns true if more than one person has a reference to this
   buffer.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-share-check">skb_share_check</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_share_check</refname>
 <refpurpose>
      check if buffer is shared and if so clone it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_share_check </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>pri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pri</parameter></term>
   <listitem>
    <para>
      priority for memory allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If the buffer is shared the buffer is cloned and the old copy
   drops a reference. A new clone with a single reference is returned.
   If the buffer is not shared the original buffer is returned. When
   being called from interrupt status or with spinlocks held pri must
   be GFP_ATOMIC.
   </para><para>

   NULL is returned on a memory allocation failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-unshare">skb_unshare</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_unshare</refname>
 <refpurpose>
      make a copy of a shared buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_unshare </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>pri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to check
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pri</parameter></term>
   <listitem>
    <para>
      priority for memory allocation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If the socket buffer is a clone then this function creates a new
   copy of the data, drops a reference count on the old copy and returns
   the new copy with the reference count at 1. If the buffer is not a clone
   the original buffer is returned. When called with a spinlock held or
   from interrupt state <parameter>pri</parameter> must be <constant>GFP_ATOMIC</constant>
   </para><para>

   <constant>NULL</constant> is returned on a memory allocation failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-peek">skb_peek</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_peek</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_peek </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list_</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list_</parameter></term>
   <listitem>
    <para>
      list to peek at
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Peek an &amp;sk_buff. Unlike most other operations you _MUST_
   be careful with this one. A peek leaves the buffer on the
   list and someone else may run off with it. You must hold
   the appropriate locks or have a private queue to do this.
   </para><para>

   Returns <constant>NULL</constant> for an empty list or a pointer to the head element.
   The reference count is not incremented and the reference is therefore
   volatile. Use with caution.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-peek-tail">skb_peek_tail</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_peek_tail</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_peek_tail </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list_</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list_</parameter></term>
   <listitem>
    <para>
      list to peek at
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Peek an &amp;sk_buff. Unlike most other operations you _MUST_
   be careful with this one. A peek leaves the buffer on the
   list and someone else may run off with it. You must hold
   the appropriate locks or have a private queue to do this.
   </para><para>

   Returns <constant>NULL</constant> for an empty list or a pointer to the tail element.
   The reference count is not incremented and the reference is therefore
   volatile. Use with caution.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-queue-len">skb_queue_len</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_queue_len</refname>
 <refpurpose>
      get queue length
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>__u32 <function>skb_queue_len </function></funcdef>
   <paramdef>const struct sk_buff_head * <parameter>list_</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list_</parameter></term>
   <listitem>
    <para>
      list to measure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Return the length of an &amp;sk_buff queue.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-put">skb_put</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_put</refname>
 <refpurpose>
      add data to a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char * <function>skb_put </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
      amount of data to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function extends the used data area of the buffer. If this would
   exceed the total buffer size the kernel will panic. A pointer to the
   first byte of the extra data is returned.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-push">skb_push</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_push</refname>
 <refpurpose>
      add data to the start of a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char * <function>skb_push </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
      amount of data to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function extends the used data area of the buffer at the buffer
   start. If this would exceed the total buffer headroom the kernel will
   panic. A pointer to the first byte of the extra data is returned.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-pull">skb_pull</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_pull</refname>
 <refpurpose>
      remove data from the start of a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char * <function>skb_pull </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
      amount of data to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function removes data from the start of a buffer, returning
   the memory to the headroom. A pointer to the next data in the buffer
   is returned. Once the data has been pulled future pushes will overwrite
   the old data.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-headroom">skb_headroom</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_headroom</refname>
 <refpurpose>
      bytes at buffer head
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_headroom </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Return the number of bytes of free space at the head of an &amp;sk_buff.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-tailroom">skb_tailroom</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_tailroom</refname>
 <refpurpose>
      bytes at buffer end
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_tailroom </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Return the number of bytes of free space at the tail of an sk_buff
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-reserve">skb_reserve</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_reserve</refname>
 <refpurpose>
      adjust headroom
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_reserve </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to alter
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
      bytes to move
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Increase the headroom of an empty &amp;sk_buff by reducing the tail
   room. This is only allowed for an empty buffer.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-trim">skb_trim</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_trim</refname>
 <refpurpose>
      remove end from a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_trim </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to alter
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
      new length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Cut the length of a buffer down by removing data from the tail. If
   the buffer is already under the length specified it is not modified.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-orphan">skb_orphan</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_orphan</refname>
 <refpurpose>
      orphan a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_orphan </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to orphan
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If a buffer currently has an owner then we call the owner's
   destructor function and make the <parameter>skb</parameter> unowned. The buffer continues
   to exist but is no longer charged to its former owner.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-alloc-skb">dev_alloc_skb</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_alloc_skb</refname>
 <refpurpose>
      allocate an skbuff for sending
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>dev_alloc_skb </function></funcdef>
   <paramdef>unsigned int <parameter>length</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
      length to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocate a new &amp;sk_buff and assign it a usage count of one. The
   buffer has unspecified headroom built in. Users should allocate
   the headroom they think they need without accounting for the
   built in space. The built in space is used for optimisations.
   </para><para>

   <constant>NULL</constant> is returned in there is no free memory. Although this function
   allocates memory it can be called from an interrupt.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-cow">skb_cow</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_cow</refname>
 <refpurpose>
      copy header of skb when it is required
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>skb_cow </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>headroom</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to cow
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>headroom</parameter></term>
   <listitem>
    <para>
      needed headroom
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If the skb passed lacks sufficient headroom or its data part
   is shared, data is reallocated. If reallocation fails, an error
   is returned and original skb is not changed.
   </para><para>

   The result is skb with writable area skb-&gt;head...skb-&gt;tail
   and at least <parameter>headroom</parameter> of space at head.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-padto">skb_padto</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_padto</refname>
 <refpurpose>
      pad an skbuff up to a minimal size
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_padto </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to pad
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
      minimal length
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Pads up a buffer to ensure the trailing bytes exist and are
   blanked. If the buffer already contains sufficient data it
   is untouched. Returns the buffer, which may be a replacement
   for the original, or NULL for out of memory - in which case
   the original buffer is still freed.
 </para>
</refsect1>
</refentry>

<!-- net/core/skbuff.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-over-panic">skb_over_panic</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_over_panic</refname>
 <refpurpose>
   	private function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_over_panic </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>sz</parameter></paramdef>
   <paramdef>void * <parameter>here</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sz</parameter></term>
   <listitem>
    <para>
      size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>here</parameter></term>
   <listitem>
    <para>
      address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Out of line support code for <function>skb_put</function>. Not user callable.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-under-panic">skb_under_panic</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_under_panic</refname>
 <refpurpose>
      	private function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_under_panic </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>sz</parameter></paramdef>
   <paramdef>void * <parameter>here</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sz</parameter></term>
   <listitem>
    <para>
      size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>here</parameter></term>
   <listitem>
    <para>
      address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Out of line support code for <function>skb_push</function>. Not user callable.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-alloc-skb">alloc_skb</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>alloc_skb</refname>
 <refpurpose>
     	allocate a network buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>alloc_skb </function></funcdef>
   <paramdef>unsigned int <parameter>size</parameter></paramdef>
   <paramdef>int <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      size to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
      allocation mask
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocate a new &amp;sk_buff. The returned buffer has no headroom and a
   tail room of size bytes. The object has a reference count of one.
   The return is the buffer. On a failure the return is <constant>NULL</constant>.
   </para><para>

   Buffers may only be allocated from interrupts using a <parameter>gfp_mask</parameter> of
   <constant>GFP_ATOMIC</constant>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---kfree-skb">__kfree_skb</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__kfree_skb</refname>
 <refpurpose>
      private function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__kfree_skb </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Free an sk_buff. Release anything attached to the buffer.
   Clean the state. This is an internal helper function. Users should
   always call kfree_skb
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-clone">skb_clone</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_clone</refname>
 <refpurpose>
     	duplicate an sk_buff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_clone </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to clone
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
      allocation priority
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Duplicate an &amp;sk_buff. The new one is not owned by a socket. Both
   copies share the same packet data but not structure. The new
   buffer has a reference count of 1. If the allocation fails the
   function returns <constant>NULL</constant> otherwise the new buffer is returned.
   </para><para>

   If this function is called from an interrupt <function>gfp_mask</function> must be
   <constant>GFP_ATOMIC</constant>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-copy">skb_copy</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_copy</refname>
 <refpurpose>
     	create private copy of an sk_buff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_copy </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to copy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
      allocation priority
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Make a copy of both an &amp;sk_buff and its data. This is used when the
   caller wishes to modify the data and needs a private copy of the
   data to alter. Returns <constant>NULL</constant> on failure or the pointer to the buffer
   on success. The returned buffer has a reference count of 1.
   </para><para>

   As by-product this function converts non-linear &amp;sk_buff to linear
   one, so that &amp;sk_buff becomes completely private and caller is allowed
   to modify all the data of returned buffer. This means that this
   function is not recommended for use in circumstances when only
   header is going to be modified. Use <function>pskb_copy</function> instead.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pskb-copy">pskb_copy</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pskb_copy</refname>
 <refpurpose>
     	create copy of an sk_buff with private head.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>pskb_copy </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to copy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
      allocation priority
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Make a copy of both an &amp;sk_buff and part of its data, located
   in header. Fragmented data remain shared. This is used when
   the caller wishes to modify only header of &amp;sk_buff and needs
   private copy of the header to alter. Returns <constant>NULL</constant> on failure
   or the pointer to the buffer on success.
   The returned buffer has a reference count of 1.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pskb-expand-head">pskb_expand_head</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pskb_expand_head</refname>
 <refpurpose>
      reallocate header of <structname>sk_buff</structname>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pskb_expand_head </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>nhead</parameter></paramdef>
   <paramdef>int <parameter>ntail</parameter></paramdef>
   <paramdef>int <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to reallocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nhead</parameter></term>
   <listitem>
    <para>
      room to add at head
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ntail</parameter></term>
   <listitem>
    <para>
      room to add at tail
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
      allocation priority
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Expands (or creates identical copy, if &amp;nhead and &amp;ntail are zero)
   header of skb. &amp;sk_buff itself is not changed. &amp;sk_buff MUST have
   reference count of 1. Returns zero in the case of success or error,
   if expansion failed. In the last case, &amp;sk_buff is not changed.
   </para><para>

   All the pointers pointing into skb header may change and must be
   reloaded after call to this function.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-copy-expand">skb_copy_expand</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_copy_expand</refname>
 <refpurpose>
     	copy and expand sk_buff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_copy_expand </function></funcdef>
   <paramdef>const struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>newheadroom</parameter></paramdef>
   <paramdef>int <parameter>newtailroom</parameter></paramdef>
   <paramdef>int <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to copy
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newheadroom</parameter></term>
   <listitem>
    <para>
      new free bytes at head
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newtailroom</parameter></term>
   <listitem>
    <para>
      new free bytes at tail
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
      allocation priority
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Make a copy of both an &amp;sk_buff and its data and while doing so
   allocate additional space.
   </para><para>

   This is used when the caller wishes to modify the data and needs a
   private copy of the data to alter as well as more space for new fields.
   Returns <constant>NULL</constant> on failure or the pointer to the buffer
   on success. The returned buffer has a reference count of 1.
   </para><para>

   You must pass <constant>GFP_ATOMIC</constant> as the allocation priority if this function
   is called from an interrupt.
 </para>
</refsect1>
<refsect1>
 <title>BUG ALERT</title>
 <para>
    ip_summed is not copied. Why does this work? Is it used
   only by netfilter in the cases when checksum is recalculated? --ANK
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-pad">skb_pad</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_pad</refname>
 <refpurpose>
     	zero pad the tail of an skb
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_pad </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>pad</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to pad
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pad</parameter></term>
   <listitem>
    <para>
      space to pad
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Ensure that a buffer is followed by a padding area that is zero
   filled. Used by network drivers which may DMA or transfer data
   beyond the buffer end onto the wire.
   </para><para>

   May return NULL in out of memory cases.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---pskb-pull-tail">__pskb_pull_tail</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__pskb_pull_tail</refname>
 <refpurpose>
      advance tail of skb header
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char * <function>__pskb_pull_tail </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>delta</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to reallocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>delta</parameter></term>
   <listitem>
    <para>
      number of bytes to advance tail
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The function makes a sense only on a fragmented &amp;sk_buff,
   it expands header moving its tail forward and copying necessary
   data from fragmented part.
   </para><para>

   &amp;sk_buff MUST have reference count of 1.
   </para><para>

   Returns <constant>NULL</constant> (and &amp;sk_buff does not change) if pull failed
   or value of new tail of skb in the case of success.
   </para><para>

   All the pointers pointing into skb header may change and must be
   reloaded after call to this function.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-dequeue">skb_dequeue</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_dequeue</refname>
 <refpurpose>
      remove from the head of the queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_dequeue </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      list to dequeue from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Remove the head of the list. The list lock is taken so the function
   may be used safely with other locking list functions. The head item is
   returned or <constant>NULL</constant> if the list is empty.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-dequeue-tail">skb_dequeue_tail</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_dequeue_tail</refname>
 <refpurpose>
      remove from the tail of the queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sk_buff * <function>skb_dequeue_tail </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      list to dequeue from
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Remove the tail of the list. The list lock is taken so the function
   may be used safely with other locking list functions. The tail item is
   returned or <constant>NULL</constant> if the list is empty.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-queue-purge">skb_queue_purge</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_queue_purge</refname>
 <refpurpose>
      empty a list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_queue_purge </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      list to empty
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Delete all buffers on an &amp;sk_buff list. Each buffer is removed from
   the list and one reference dropped. This function takes the list
   lock and is atomic with respect to other list locking functions.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-queue-head">skb_queue_head</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_queue_head</refname>
 <refpurpose>
      queue a buffer at the list head
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_queue_head </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>newsk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      list to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newsk</parameter></term>
   <listitem>
    <para>
      buffer to queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Queue a buffer at the start of the list. This function takes the
   list lock and can be used safely with other locking &amp;sk_buff functions
   safely.
   </para><para>

   A buffer cannot be placed on two lists at the same time.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-queue-tail">skb_queue_tail</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_queue_tail</refname>
 <refpurpose>
      queue a buffer at the list tail
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_queue_tail </function></funcdef>
   <paramdef>struct sk_buff_head * <parameter>list</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>newsk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
      list to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newsk</parameter></term>
   <listitem>
    <para>
      buffer to queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Queue a buffer at the tail of the list. This function takes the
   list lock and can be used safely with other locking &amp;sk_buff functions
   safely.
   </para><para>

   A buffer cannot be placed on two lists at the same time.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-unlink">skb_unlink</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_unlink</refname>
 <refpurpose>
     	remove a buffer from a list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_unlink </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Place a packet after a given packet in a list. The list locks are taken
   and this function is atomic with respect to other list locked calls
   </para><para>

   Works even without knowing the list it is sitting on, which can be
   handy at times. It also means that THE LIST MUST EXIST when you
   unlink. Thus a list must have its contents unlinked before it is
   destroyed.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-append">skb_append</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_append</refname>
 <refpurpose>
     	append a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_append </function></funcdef>
   <paramdef>struct sk_buff * <parameter>old</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>newsk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>old</parameter></term>
   <listitem>
    <para>
      buffer to insert after
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newsk</parameter></term>
   <listitem>
    <para>
      buffer to insert
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Place a packet after a given packet in a list. The list locks are taken
   and this function is atomic with respect to other list locked calls.
   A buffer cannot be placed on two lists at the same time.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-insert">skb_insert</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_insert</refname>
 <refpurpose>
     	insert a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_insert </function></funcdef>
   <paramdef>struct sk_buff * <parameter>old</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>newsk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>old</parameter></term>
   <listitem>
    <para>
      buffer to insert before
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newsk</parameter></term>
   <listitem>
    <para>
      buffer to insert
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Place a packet before a given packet in a list. The list locks are taken
   and this function is atomic with respect to other list locked calls
   A buffer cannot be placed on two lists at the same time.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-skb-split">skb_split</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>skb_split</refname>
 <refpurpose>
      Split fragmented skb to two parts at length len.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>skb_split </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb1</parameter></paramdef>
   <paramdef>const u32 <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb1</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Socket Filter</title>
<!-- net/core/filter.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-sk-run-filter">sk_run_filter</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sk_run_filter</refname>
 <refpurpose>
   	run a filter on a socket
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sk_run_filter </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>struct sock_filter * <parameter>filter</parameter></paramdef>
   <paramdef>int <parameter>flen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to run the filter on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filter</parameter></term>
   <listitem>
    <para>
      filter to apply
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flen</parameter></term>
   <listitem>
    <para>
      length of filter
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Decode and apply filter instructions to the skb-&gt;data.
   Return length to keep, 0 for none. skb is the data we are
   filtering, filter is the array of filter instructions, and
   len is the number of filter blocks in the array.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sk-chk-filter">sk_chk_filter</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sk_chk_filter</refname>
 <refpurpose>
      verify socket filter code
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sk_chk_filter </function></funcdef>
   <paramdef>struct sock_filter * <parameter>filter</parameter></paramdef>
   <paramdef>int <parameter>flen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>filter</parameter></term>
   <listitem>
    <para>
      filter to verify
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flen</parameter></term>
   <listitem>
    <para>
      length of filter
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Check the user's filter code. If we let some ugly
   filter code slip through kaboom! The filter must contain
   no references or jumps that are out of range, no illegal instructions
   and no backward jumps. It must end with a RET instruction
   </para><para>

   Returns 0 if the rule set is legal or a negative errno code if not.
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Generic Network Statistics</title>
<!-- include/linux/gen_stats.h -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-struct-gnet-stats-basic">struct gnet_stats_basic</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>struct gnet_stats_basic</refname>
 <refpurpose>
   byte/packet throughput statistics
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct gnet_stats_basic {
  __u64 bytes;
  __u32 packets;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>bytes</term>
      <listitem><para>
 number of seen bytes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>packets</term>
      <listitem><para>
 number of seen packets
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-struct-gnet-stats-rate-est">struct gnet_stats_rate_est</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>struct gnet_stats_rate_est</refname>
 <refpurpose>
      rate estimator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct gnet_stats_rate_est {
  __u32 bps;
  __u32 pps;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>bps</term>
      <listitem><para>
    current byte rate
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pps</term>
      <listitem><para>
    current packet rate
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-struct-gnet-stats-queue">struct gnet_stats_queue</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>struct gnet_stats_queue</refname>
 <refpurpose>
      queuing statistics
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct gnet_stats_queue {
  __u32 qlen;
  __u32 backlog;
  __u32 drops;
  __u32 requeues;
  __u32 overlimits;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>qlen</term>
      <listitem><para>
    queue length
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>backlog</term>
      <listitem><para>
    backlog size of queue
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>drops</term>
      <listitem><para>
    number of dropped packets
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>requeues</term>
      <listitem><para>
    number of requeues
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>overlimits</term>
      <listitem><para>
    number of enqueues over the limit
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-struct-gnet-estimator">struct gnet_estimator</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>struct gnet_estimator</refname>
 <refpurpose>
      rate estimator configuration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct gnet_estimator {
  signed char interval;
  unsigned char ewma_log;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>interval</term>
      <listitem><para>
    sampling period
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ewma_log</term>
      <listitem><para>
    the log of measurement window weight
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- net/core/gen_stats.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-gnet-stats-start-copy-compat">gnet_stats_start_copy_compat</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>gnet_stats_start_copy_compat</refname>
 <refpurpose>
   start dumping procedure in compatibility mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_start_copy_compat </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>int <parameter>tc_stats_type</parameter></paramdef>
   <paramdef>int <parameter>xstats_type</parameter></paramdef>
   <paramdef>spinlock_t * <parameter>lock</parameter></paramdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      socket buffer to put statistics TLVs into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
      TLV type for top level statistic TLV
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tc_stats_type</parameter></term>
   <listitem>
    <para>
      TLV type for backward compatibility struct tc_stats TLV
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>xstats_type</parameter></term>
   <listitem>
    <para>
      TLV type for backward compatibility xstats TLV
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lock</parameter></term>
   <listitem>
    <para>
      statistics lock
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
      dumping handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Initializes the dumping handle, grabs the statistic lock and appends
   an empty TLV header to the socket buffer for use a container for all
   other statistic TLVS.
   </para><para>

   The dumping handle is marked to be in backward compatibility mode telling
   all <function>gnet_stats_copy_XXX</function> functions to fill a local copy of struct tc_stats.
   </para><para>

   Returns 0 on success or -1 if the room in the socket buffer was not sufficient.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-gnet-stats-start-copy">gnet_stats_start_copy</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>gnet_stats_start_copy</refname>
 <refpurpose>
      start dumping procedure in compatibility mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_start_copy </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>spinlock_t * <parameter>lock</parameter></paramdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      socket buffer to put statistics TLVs into
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
      TLV type for top level statistic TLV
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lock</parameter></term>
   <listitem>
    <para>
      statistics lock
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
      dumping handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Initializes the dumping handle, grabs the statistic lock and appends
   an empty TLV header to the socket buffer for use a container for all
   other statistic TLVS.
   </para><para>

   Returns 0 on success or -1 if the room in the socket buffer was not sufficient.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-gnet-stats-copy-basic">gnet_stats_copy_basic</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>gnet_stats_copy_basic</refname>
 <refpurpose>
      copy basic statistics into statistic TLV
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_copy_basic </function></funcdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
   <paramdef>struct gnet_stats_basic * <parameter>b</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
      dumping handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>b</parameter></term>
   <listitem>
    <para>
      basic statistics
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Appends the basic statistics to the top level TLV created by
   <function>gnet_stats_start_copy</function>.
   </para><para>

   Returns 0 on success or -1 with the statistic lock released
   if the room in the socket buffer was not sufficient.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-gnet-stats-copy-rate-est">gnet_stats_copy_rate_est</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>gnet_stats_copy_rate_est</refname>
 <refpurpose>
      copy rate estimator statistics into statistics TLV
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_copy_rate_est </function></funcdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
   <paramdef>struct gnet_stats_rate_est * <parameter>r</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
      dumping handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
      rate estimator statistics
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Appends the rate estimator statistics to the top level TLV created by
   <function>gnet_stats_start_copy</function>.
   </para><para>

   Returns 0 on success or -1 with the statistic lock released
   if the room in the socket buffer was not sufficient.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-gnet-stats-copy-queue">gnet_stats_copy_queue</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>gnet_stats_copy_queue</refname>
 <refpurpose>
      copy queue statistics into statistics TLV
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_copy_queue </function></funcdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
   <paramdef>struct gnet_stats_queue * <parameter>q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
      dumping handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
      queue statistics
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Appends the queue statistics to the top level TLV created by
   <function>gnet_stats_start_copy</function>.
   </para><para>

   Returns 0 on success or -1 with the statistic lock released
   if the room in the socket buffer was not sufficient.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-gnet-stats-copy-app">gnet_stats_copy_app</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>gnet_stats_copy_app</refname>
 <refpurpose>
      copy application specific statistics into statistics TLV
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_copy_app </function></funcdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
   <paramdef>void * <parameter>st</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
      dumping handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>st</parameter></term>
   <listitem>
    <para>
      application specific statistics data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
      length of data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Appends the application sepecific statistics to the top level TLV created by
   <function>gnet_stats_start_copy</function> and remembers the data for XSTATS if the dumping
   handle is in backward compatibility mode.
   </para><para>

   Returns 0 on success or -1 with the statistic lock released
   if the room in the socket buffer was not sufficient.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-gnet-stats-finish-copy">gnet_stats_finish_copy</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>gnet_stats_finish_copy</refname>
 <refpurpose>
      finish dumping procedure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gnet_stats_finish_copy </function></funcdef>
   <paramdef>struct gnet_dump * <parameter>d</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
      dumping handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Corrects the length of the top level TLV to include all TLVs added
   by <function>gnet_stats_copy_XXX</function> calls. Adds the backward compatibility TLVs
   if <function>gnet_stats_start_copy_compat</function> was used and releases the statistics
   lock.
   </para><para>

   Returns 0 on success or -1 with the statistic lock released
   if the room in the socket buffer was not sufficient.
 </para>
</refsect1>
</refentry>

<!-- net/core/gen_estimator.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-gen-new-estimator">gen_new_estimator</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>gen_new_estimator</refname>
 <refpurpose>
   create a new rate estimator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gen_new_estimator </function></funcdef>
   <paramdef>struct gnet_stats_basic * <parameter>bstats</parameter></paramdef>
   <paramdef>struct gnet_stats_rate_est * <parameter>rate_est</parameter></paramdef>
   <paramdef>spinlock_t * <parameter>stats_lock</parameter></paramdef>
   <paramdef>struct rtattr * <parameter>opt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bstats</parameter></term>
   <listitem>
    <para>
      basic statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rate_est</parameter></term>
   <listitem>
    <para>
      rate estimator statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>stats_lock</parameter></term>
   <listitem>
    <para>
      statistics lock
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>opt</parameter></term>
   <listitem>
    <para>
      rate estimator configuration TLV
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Creates a new rate estimator with &amp;bstats as source and &amp;rate_est
   as destination. A new timer with the interval specified in the
   configuration TLV is created. Upon each interval, the latest statistics
   will be read from &amp;bstats and the estimated rate will be stored in
   &amp;rate_est with the statistics lock grabed during this period.
   </para><para>

   Returns 0 on success or a negative error code.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-gen-kill-estimator">gen_kill_estimator</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>gen_kill_estimator</refname>
 <refpurpose>
      remove a rate estimator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>gen_kill_estimator </function></funcdef>
   <paramdef>struct gnet_stats_basic * <parameter>bstats</parameter></paramdef>
   <paramdef>struct gnet_stats_rate_est * <parameter>rate_est</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bstats</parameter></term>
   <listitem>
    <para>
      basic statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rate_est</parameter></term>
   <listitem>
    <para>
      rate estimator statistics
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Removes the rate estimator specified by &amp;bstats and &amp;rate_est
   and deletes the timer.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-gen-replace-estimator">gen_replace_estimator</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>gen_replace_estimator</refname>
 <refpurpose>
      replace rate estimator configruation
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>gen_replace_estimator </function></funcdef>
   <paramdef>struct gnet_stats_basic * <parameter>bstats</parameter></paramdef>
   <paramdef>struct gnet_stats_rate_est * <parameter>rate_est</parameter></paramdef>
   <paramdef>spinlock_t * <parameter>stats_lock</parameter></paramdef>
   <paramdef>struct rtattr * <parameter>opt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bstats</parameter></term>
   <listitem>
    <para>
      basic statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rate_est</parameter></term>
   <listitem>
    <para>
      rate estimator statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>stats_lock</parameter></term>
   <listitem>
    <para>
      statistics lock
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>opt</parameter></term>
   <listitem>
    <para>
      rate estimator configuration TLV
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Replaces the configuration of a rate estimator by calling
   <function>gen_kill_estimator</function> and <function>gen_new_estimator</function>.
   </para><para>

   Returns 0 on success or a negative error code.
 </para>
</refsect1>
</refentry>

     </sect1>
  </chapter>

  <chapter id="netdev">
     <title>Network device support</title>
     <sect1><title>Driver Support</title>
<!-- net/core/dev.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-add-pack">dev_add_pack</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_add_pack</refname>
 <refpurpose>
   add packet handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_add_pack </function></funcdef>
   <paramdef>struct packet_type * <parameter>pt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pt</parameter></term>
   <listitem>
    <para>
      packet type declaration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Add a protocol handler to the networking stack. The passed &amp;packet_type
   is linked into kernel lists and may not be freed until it has been
   removed from the kernel lists.
   </para><para>

   This call does not sleep therefore it can not 
   guarantee all CPU's that are in middle of receiving packets
   will see the new packet type (until the next received packet).
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---dev-remove-pack">__dev_remove_pack</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__dev_remove_pack</refname>
 <refpurpose>
      remove packet handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__dev_remove_pack </function></funcdef>
   <paramdef>struct packet_type * <parameter>pt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pt</parameter></term>
   <listitem>
    <para>
      packet type declaration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Remove a protocol handler that was previously added to the kernel
   protocol handlers by <function>dev_add_pack</function>. The passed &amp;packet_type is removed
   from the kernel lists and can be freed or reused once this function
   returns. 
   </para><para>

   The packet type might still be in use by receivers
   and must not be freed until after all the CPU's have gone
   through a quiescent state.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-remove-pack">dev_remove_pack</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_remove_pack</refname>
 <refpurpose>
      remove packet handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_remove_pack </function></funcdef>
   <paramdef>struct packet_type * <parameter>pt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pt</parameter></term>
   <listitem>
    <para>
      packet type declaration
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Remove a protocol handler that was previously added to the kernel
   protocol handlers by <function>dev_add_pack</function>. The passed &amp;packet_type is removed
   from the kernel lists and can be freed or reused once this function
   returns.
   </para><para>

   This call sleeps to guarantee that no CPU is looking at the packet
   type after return.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-netdev-boot-setup-check">netdev_boot_setup_check</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>netdev_boot_setup_check</refname>
 <refpurpose>
      check boot time settings
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>netdev_boot_setup_check </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      the netdevice
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Check boot time settings for the device.
   The found settings are set for the device to be used
   later in the device probing.
   Returns 0 if no settings found, 1 if they are.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---dev-get-by-name">__dev_get_by_name</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__dev_get_by_name</refname>
 <refpurpose>
      find a device by its name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>__dev_get_by_name </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      name to find
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Find an interface by name. Must be called under RTNL semaphore
   or <parameter>dev_base_lock</parameter>. If the name is found a pointer to the device
   is returned. If the name is not found then <constant>NULL</constant> is returned. The
   reference counters are not incremented so the caller must be
   careful with locks.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-get-by-name">dev_get_by_name</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_get_by_name</refname>
 <refpurpose>
      find a device by its name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>dev_get_by_name </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      name to find
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Find an interface by name. This can be called from any
   context and does its own locking. The returned handle has
   the usage count incremented and the caller must use <function>dev_put</function> to
   release it when it is no longer needed. <constant>NULL</constant> is returned if no
   matching device is found.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---dev-get-by-index">__dev_get_by_index</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__dev_get_by_index</refname>
 <refpurpose>
      find a device by its ifindex
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>__dev_get_by_index </function></funcdef>
   <paramdef>int <parameter>ifindex</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ifindex</parameter></term>
   <listitem>
    <para>
      index of device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Search for an interface by index. Returns <constant>NULL</constant> if the device
   is not found or a pointer to the device. The device has not
   had its reference counter increased so the caller must be careful
   about locking. The caller must hold either the RTNL semaphore
   or <parameter>dev_base_lock</parameter>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-get-by-index">dev_get_by_index</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_get_by_index</refname>
 <refpurpose>
      find a device by its ifindex
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>dev_get_by_index </function></funcdef>
   <paramdef>int <parameter>ifindex</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ifindex</parameter></term>
   <listitem>
    <para>
      index of device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Search for an interface by index. Returns NULL if the device
   is not found or a pointer to the device. The device returned has
   had a reference added and the pointer is safe until the user calls
   dev_put to indicate they have finished with it.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-get-by-flags">dev_get_by_flags</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_get_by_flags</refname>
 <refpurpose>
      find any device with given flags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>dev_get_by_flags </function></funcdef>
   <paramdef>unsigned short <parameter>if_flags</parameter></paramdef>
   <paramdef>unsigned short <parameter>mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>if_flags</parameter></term>
   <listitem>
    <para>
      IFF_* values
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mask</parameter></term>
   <listitem>
    <para>
      bitmask of bits in if_flags to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Search for any interface with the given flags. Returns NULL if a device
   is not found or a pointer to the device. The device returned has 
   had a reference added and the pointer is safe until the user calls
   dev_put to indicate they have finished with it.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-alloc-name">dev_alloc_name</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_alloc_name</refname>
 <refpurpose>
      allocate a name for a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_alloc_name </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      name format string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Passed a format string - eg <quote>lt<constant>d</constant></quote> it will try and find a suitable
   id. Not efficient for many devices, not called a lot. The caller
   must hold the dev_base or rtnl lock while allocating the name and
   adding the device in order to avoid duplicates. Returns the number
   of the unit assigned or a negative errno code.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-netdev-state-change">netdev_state_change</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>netdev_state_change</refname>
 <refpurpose>
      device changes state
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>netdev_state_change </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      device to cause notification
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Called to indicate a device has changed state. This function calls
   the notifier chains for netdev_chain and sends a NEWLINK message
   to the routing socket.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-load">dev_load</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_load</refname>
 <refpurpose>
      load a network module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_load </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      name of interface
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If a network interface is not present and the process has suitable
   privileges this function loads the module. If module loading is not
   available in this kernel then it becomes a nop.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-open">dev_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_open</refname>
 <refpurpose>
      prepare an interface for use.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_open </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     	device to open
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Takes a device from down to up state. The device's private open
   function is invoked and then the multicast lists are loaded. Finally
   the device is moved into the up state and a <constant>NETDEV_UP</constant> message is
   sent to the netdev notifier chain.
   </para><para>

   Calling this function on an active interface is a nop. On a failure
   a negative errno code is returned.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-close">dev_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_close</refname>
 <refpurpose>
      shutdown an interface.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_close </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      device to shutdown
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function moves an active device into down state. A
   <constant>NETDEV_GOING_DOWN</constant> is sent to the netdev notifier chain. The device
   is then deactivated and finally a <constant>NETDEV_DOWN</constant> is sent to the notifier
   chain.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-netdevice-notifier">register_netdevice_notifier</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_netdevice_notifier</refname>
 <refpurpose>
      register a network notifier block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_netdevice_notifier </function></funcdef>
   <paramdef>struct notifier_block * <parameter>nb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nb</parameter></term>
   <listitem>
    <para>
      notifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Register a notifier to be called when network device events occur.
   The notifier passed is linked into the kernel structures and must
   not be reused until it has been unregistered. A negative errno code
   is returned on a failure.
   </para><para>

   When registered all registration and up events are replayed
   to the new notifier to allow device to have a race free 
   view of the network device list.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-unregister-netdevice-notifier">unregister_netdevice_notifier</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>unregister_netdevice_notifier</refname>
 <refpurpose>
      unregister a network notifier block
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>unregister_netdevice_notifier </function></funcdef>
   <paramdef>struct notifier_block * <parameter>nb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nb</parameter></term>
   <listitem>
    <para>
      notifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Unregister a notifier previously registered by
   <function>register_netdevice_notifier</function>. The notifier is unlinked into the
   kernel structures and may then be reused. A negative errno code
   is returned on a failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-queue-xmit">dev_queue_xmit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_queue_xmit</refname>
 <refpurpose>
      transmit a buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_queue_xmit </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to transmit
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Queue a buffer for transmission to a network device. The caller must
   have set the device and priority and built the buffer before calling
   this function. The function can be called from an interrupt.
   </para><para>

   A negative errno code is returned on a failure. A success does not
   guarantee the frame will be transmitted as it may be dropped due
   to congestion or traffic shaping.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-netif-rx">netif_rx</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>netif_rx</refname>
 <refpurpose>
     	post buffer to the network code
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>netif_rx </function></funcdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      buffer to post
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function receives a packet from a device driver and queues it for
   the upper (protocol) levels to process.  It always succeeds. The buffer
   may be dropped during processing for congestion control or by the
   protocol layers.
 </para>
</refsect1>
<refsect1>
 <title>return values</title>
 <para>
   NET_RX_SUCCESS	(no congestion)
   NET_RX_CN_LOW   (low congestion)
   NET_RX_CN_MOD   (moderate congestion)
   NET_RX_CN_HIGH  (high congestion)
   NET_RX_DROP     (packet was dropped)
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-gifconf">register_gifconf</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_gifconf</refname>
 <refpurpose>
     	register a SIOCGIF handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_gifconf </function></funcdef>
   <paramdef>unsigned int <parameter>family</parameter></paramdef>
   <paramdef>gifconf_func_t * <parameter>gifconf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>family</parameter></term>
   <listitem>
    <para>
      Address family
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gifconf</parameter></term>
   <listitem>
    <para>
      Function handler
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Register protocol dependent address dumping routines. The handler
   that is passed must not be freed or reused until it has been replaced
   by another handler.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-netdev-set-master">netdev_set_master</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>netdev_set_master</refname>
 <refpurpose>
     	set up master/slave pair
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>netdev_set_master </function></funcdef>
   <paramdef>struct net_device * <parameter>slave</parameter></paramdef>
   <paramdef>struct net_device * <parameter>master</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>slave</parameter></term>
   <listitem>
    <para>
      slave device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>master</parameter></term>
   <listitem>
    <para>
      new master device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Changes the master device of the slave. Pass <constant>NULL</constant> to break the
   bonding. The caller must hold the RTNL semaphore. On a failure
   a negative errno code is returned. On success the reference counts
   are adjusted, <constant>RTM_NEWLINK</constant> is sent to the routing socket and the
   function returns zero.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-set-promiscuity">dev_set_promiscuity</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_set_promiscuity</refname>
 <refpurpose>
      update promiscuity count on a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_set_promiscuity </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>inc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inc</parameter></term>
   <listitem>
    <para>
      modifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Add or remove promsicuity from a device. While the count in the device
   remains above zero the interface remains promiscuous. Once it hits zero
   the device reverts back to normal filtering operation. A negative inc
   value is used to drop promiscuity on the device.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-set-allmulti">dev_set_allmulti</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_set_allmulti</refname>
 <refpurpose>
      update allmulti count on a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dev_set_allmulti </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>inc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inc</parameter></term>
   <listitem>
    <para>
      modifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Add or remove reception of all multicast frames to a device. While the
   count in the device remains above zero the interface remains listening
   to all interfaces. Once it hits zero the device reverts back to normal
   filtering operation. A negative <parameter>inc</parameter> value is used to drop the counter
   when releasing a resource needing all multicasts.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-dev-ioctl">dev_ioctl</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>dev_ioctl</refname>
 <refpurpose>
     	network device ioctl
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_ioctl </function></funcdef>
   <paramdef>unsigned int <parameter>cmd</parameter></paramdef>
   <paramdef>void __user * <parameter>arg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
      command to issue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arg</parameter></term>
   <listitem>
    <para>
      pointer to a struct ifreq in user space
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Issue ioctl functions to devices. This is normally called by the
   user space syscall interfaces but can sometimes be useful for
   other purposes. The return value is the return from the syscall if
   positive or a negative errno code on error.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-netdevice">register_netdevice</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_netdevice</refname>
 <refpurpose>
      register a network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_netdevice </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      device to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Take a completed network device structure and add it to the kernel
   interfaces. A <constant>NETDEV_REGISTER</constant> message is sent to the netdev notifier
   chain. 0 is returned on success. A negative errno code is returned
   on a failure to set up the device, or if the name is a duplicate.
   </para><para>

   Callers must hold the rtnl semaphore. You may want
   <function>register_netdev</function> instead of this.
 </para>
</refsect1>
<refsect1>
 <title>BUGS</title>
 <para>
   The locking appears insufficient to guarantee two parallel registers
   will not get the same name.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-netdev">register_netdev</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_netdev</refname>
 <refpurpose>
      register a network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_netdev </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      device to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Take a completed network device structure and add it to the kernel
   interfaces. A <constant>NETDEV_REGISTER</constant> message is sent to the netdev notifier
   chain. 0 is returned on success. A negative errno code is returned
   on a failure to set up the device, or if the name is a duplicate.
   </para><para>

   This is a wrapper around register_netdev that takes the rtnl semaphore
   and expands the device name if you passed a format string to
   alloc_netdev.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-alloc-netdev">alloc_netdev</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>alloc_netdev</refname>
 <refpurpose>
      allocate network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>alloc_netdev </function></funcdef>
   <paramdef>int <parameter>sizeof_priv</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>void (*<parameter>setup</parameter>)
     <funcparams>struct net_device *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sizeof_priv</parameter></term>
   <listitem>
    <para>
     	size of private data to allocate space for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     		device name format string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>setup</parameter></term>
   <listitem>
    <para>
     		callback to initialize device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocates a struct net_device with private data area for driver use
   and performs basic initialization.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-free-netdev">free_netdev</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>free_netdev</refname>
 <refpurpose>
      free network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>free_netdev </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function does the last stage of destroying an allocated device 
   interface. The reference to the device object is released.  
   If this is the last reference then it will be freed.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-unregister-netdevice">unregister_netdevice</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>unregister_netdevice</refname>
 <refpurpose>
      remove device from the kernel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>unregister_netdevice </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function shuts down a device interface and removes it
   from the kernel tables. On success 0 is returned, on a failure
   a negative errno code is returned.
   </para><para>

   Callers must hold the rtnl semaphore.  You may want
   <function>unregister_netdev</function> instead of this.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-unregister-netdev">unregister_netdev</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>unregister_netdev</refname>
 <refpurpose>
      remove device from the kernel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_netdev </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function shuts down a device interface and removes it
   from the kernel tables. On success 0 is returned, on a failure
   a negative errno code is returned.
   </para><para>

   This is just a wrapper for unregister_netdevice that takes
   the rtnl semaphore.  In general you want to use this and not
   unregister_netdevice.
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>8390 Based Network Cards</title>
<!-- drivers/net/8390.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-ei-open">ei_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>ei_open</refname>
 <refpurpose>
   Open/initialize the board.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ei_open </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      network device to initialize
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This routine goes all-out, setting everything
   up anew at each open, even though many of these registers should only
   need to be set once at boot.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-ei-close">ei_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>ei_close</refname>
 <refpurpose>
      shut down network device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ei_close </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      network device to close
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Opposite of <function>ei_open</function>. Only used when <quote>ifconfig &lt;devname&gt; down</quote> is done.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-ei-interrupt">ei_interrupt</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>ei_interrupt</refname>
 <refpurpose>
      handle the interrupts from an 8390
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>irqreturn_t <function>ei_interrupt </function></funcdef>
   <paramdef>int <parameter>irq</parameter></paramdef>
   <paramdef>void * <parameter>dev_id</parameter></paramdef>
   <paramdef>struct pt_regs * <parameter>regs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
      interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev_id</parameter></term>
   <listitem>
    <para>
      a pointer to the net_device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>regs</parameter></term>
   <listitem>
    <para>
      unused
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Handle the ether interface interrupts. We pull packets from
   the 8390 via the card specific functions and fire them at the networking
   stack. We also handle transmit completions and wake the transmit path if
   necessary. We also update the counters and do other housekeeping as
   needed.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API---alloc-ei-netdev">__alloc_ei_netdev</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>__alloc_ei_netdev</refname>
 <refpurpose>
      alloc_etherdev counterpart for 8390
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device * <function>__alloc_ei_netdev </function></funcdef>
   <paramdef>int <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   Allocate 8390-specific net_device.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-NS8390-init">NS8390_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>NS8390_init</refname>
 <refpurpose>
      initialize 8390 hardware
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>NS8390_init </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>startp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      network device to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>startp</parameter></term>
   <listitem>
    <para>
      boolean.  non-zero value to initiate chip processing
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Must be called with lock held.
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Synchronous PPP</title>
<!-- drivers/net/wan/syncppp.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-input">sppp_input</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_input</refname>
 <refpurpose>
  	receive and process a WAN PPP frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sppp_input </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     	The device it arrived on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
     	The buffer to process
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This can be called directly by cards that do not have
   timing constraints but is normally called from the network layer
   after interrupt servicing to process frames queued via <function>netif_rx</function>.
   </para><para>

   We process the options in the card. If the frame is destined for
   the protocol stacks then it requeues the frame for the upper level
   protocol. If it is a control from it is processed and discarded
   here.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-close">sppp_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_close</refname>
 <refpurpose>
      close down a synchronous PPP or Cisco HDLC link
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sppp_close </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      The network device to drop the link of
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This drops the logical interface to the channel. It is not
   done politely as we assume we will also be dropping DTR. Any
   timeouts are killed.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-open">sppp_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_open</refname>
 <refpurpose>
      open a synchronous PPP or Cisco HDLC link
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sppp_open </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     	Network device to activate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Close down any existing synchronous session and commence
   from scratch. In the PPP case this means negotiating LCP/IPCP
   and friends, while for Cisco HDLC we simply need to start sending
   keepalives
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-reopen">sppp_reopen</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_reopen</refname>
 <refpurpose>
      notify of physical link loss
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sppp_reopen </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Device that lost the link
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function informs the synchronous protocol code that
   the underlying link died (for example a carrier drop on X.21)
   </para><para>

   We increment the magic numbers to ensure that if the other end
   failed to notice we will correctly start a new session. It happens
   do to the nature of telco circuits is that you can lose carrier on
   one endonly.
   </para><para>

   Having done this we go back to negotiating. This function may
   be called from an interrupt context.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-change-mtu">sppp_change_mtu</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_change_mtu</refname>
 <refpurpose>
      Change the link MTU
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sppp_change_mtu </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>new_mtu</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     	Device to change MTU on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_mtu</parameter></term>
   <listitem>
    <para>
      New MTU
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Change the MTU on the link. This can only be called with
   the link down. It returns an error if the link is up or
   the mtu is out of range.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-do-ioctl">sppp_do_ioctl</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_do_ioctl</refname>
 <refpurpose>
      Ioctl handler for ppp/hdlc
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sppp_do_ioctl </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct ifreq * <parameter>ifr</parameter></paramdef>
   <paramdef>int <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Device subject to ioctl
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ifr</parameter></term>
   <listitem>
    <para>
      Interface request block from the user
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
      Command that is being issued
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function handles the ioctls that may be issued by the user
   to control the settings of a PPP/HDLC link. It does both busy
   and security checks. This function is intended to be wrapped by
   callers who wish to add additional ioctl calls of their own.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-attach">sppp_attach</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_attach</refname>
 <refpurpose>
      attach synchronous PPP/HDLC to a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sppp_attach </function></funcdef>
   <paramdef>struct ppp_device * <parameter>pd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pd</parameter></term>
   <listitem>
    <para>
     	PPP device to initialise
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This initialises the PPP/HDLC support on an interface. At the
   time of calling the dev element must point to the network device
   that this interface is attached to. The interface should not yet
   be registered. 
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-sppp-detach">sppp_detach</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>sppp_detach</refname>
 <refpurpose>
      release PPP resources from a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sppp_detach </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     	Network device to release
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Stop and free up any PPP/HDLC resources used by this
   interface. This must be called before the device is
   freed.
 </para>
</refsect1>
</refentry>

     </sect1>
  </chapter>

  <chapter id="modload">
     <title>Module Support</title>
     <sect1><title>Module Loading</title>
<!-- kernel/kmod.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-request-module">request_module</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>request_module</refname>
 <refpurpose>
   try to load a kernel module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>request_module </function></funcdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
          printf style format string for the name of the module
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Load a module using the user mode module loader. The function returns
   zero on success or a negative errno code on failure. Note that a
   successful module load does not mean the module did not then unload
   and exit on an error of its own. Callers must check that the service
   they requested is now available not blindly invoke it.
   </para><para>

   If module auto-loading support is disabled then this function
   becomes a no-operation.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-call-usermodehelper">call_usermodehelper</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>call_usermodehelper</refname>
 <refpurpose>
      start a usermode application
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>call_usermodehelper </function></funcdef>
   <paramdef>char * <parameter>path</parameter></paramdef>
   <paramdef>char ** <parameter>argv</parameter></paramdef>
   <paramdef>char ** <parameter>envp</parameter></paramdef>
   <paramdef>int <parameter>wait</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>path</parameter></term>
   <listitem>
    <para>
      pathname for the application
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>argv</parameter></term>
   <listitem>
    <para>
      null-terminated argument list
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>envp</parameter></term>
   <listitem>
    <para>
      null-terminated environment list
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>wait</parameter></term>
   <listitem>
    <para>
      wait for the application to finish and return status.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Runs a user-space application.  The application is started
   asynchronously if wait is not set, and runs as a child of keventd.
   (ie. it runs with full root capabilities).
   </para><para>

   Must be called from process context.  Returns a negative error code
   if program was not execed successfully, or 0.
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Inter Module support</title>
        <para>
           Refer to the file kernel/module.c for more information.
        </para>
<!-- FIXME: Removed for now since no structured comments in source
X!Ekernel/module.c
-->
     </sect1>
  </chapter>

  <chapter id="hardware">
     <title>Hardware Interfaces</title>
     <sect1><title>Interrupt Handling</title>
<!-- arch/i386/kernel/irq.c -->
<refentry>
 <refnamediv>
  <refname>
   /home/liuhaozzu/repoes/linux/kernels/linux-2.6.11/arch/i386/kernel/irq.c
  </refname>
  <refpurpose>
   Document generation inconsistency
  </refpurpose>
 </refnamediv>
 <refsect1>
  <title>
   Oops
  </title>
  <warning>
   <para>
    The template for this document tried to insert
    the structured comment from the file
    <filename>/home/liuhaozzu/repoes/linux/kernels/linux-2.6.11/arch/i386/kernel/irq.c</filename> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </para>
  </warning>
 </refsect1>
</refentry>
     </sect1>

     <sect1><title>MTRR Handling</title>
<!-- arch/i386/kernel/cpu/mtrr/main.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-mtrr-add">mtrr_add</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mtrr_add</refname>
 <refpurpose>
   Add a memory type region
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mtrr_add </function></funcdef>
   <paramdef>unsigned long <parameter>base</parameter></paramdef>
   <paramdef>unsigned long <parameter>size</parameter></paramdef>
   <paramdef>unsigned int <parameter>type</parameter></paramdef>
   <paramdef>char <parameter>increment</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>base</parameter></term>
   <listitem>
    <para>
      Physical base address of region
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      Physical size of region
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
      Type of MTRR desired
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>increment</parameter></term>
   <listitem>
    <para>
      If this is true do usage counting on the region
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Memory type region registers control the caching on newer Intel and
   non Intel processors. This function allows drivers to request an
   MTRR is added. The details and hardware specifics of each processor's
   implementation are hidden from the caller, but nevertheless the 
   caller should expect to need to provide a power of two size on an
   equivalent power of two boundary.
   </para><para>

   If the region cannot be added either because all regions are in use
   or the CPU cannot support it a negative value is returned. On success
   the register number for this entry is returned, but should be treated
   as a cookie only.
   </para><para>

   On a multiprocessor machine the changes are made to all processors.
   This is required on x86 by the Intel processors.
   </para><para>

   The available types are
   </para><para>

   <constant>MTRR_TYPE_UNCACHABLE</constant>	-	No caching
   </para><para>

   <constant>MTRR_TYPE_WRBACK</constant>	-	Write data back in bursts whenever
   </para><para>

   <constant>MTRR_TYPE_WRCOMB</constant>	-	Write data back soon but allow bursts
   </para><para>

   <constant>MTRR_TYPE_WRTHROUGH</constant>	-	Cache reads but not writes
 </para>
</refsect1>
<refsect1>
 <title>BUGS</title>
 <para>
    Needs a quiet flag for the cases where drivers do not mind
   failures and do not wish system log messages to be sent.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mtrr-del">mtrr_del</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mtrr_del</refname>
 <refpurpose>
      delete a memory type region
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mtrr_del </function></funcdef>
   <paramdef>int <parameter>reg</parameter></paramdef>
   <paramdef>unsigned long <parameter>base</parameter></paramdef>
   <paramdef>unsigned long <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>reg</parameter></term>
   <listitem>
    <para>
      Register returned by mtrr_add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base</parameter></term>
   <listitem>
    <para>
      Physical base address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
      Size of region
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If register is supplied then base and size are ignored. This is
   how drivers should call it.
   </para><para>

   Releases an MTRR region. If the usage count drops to zero the 
   register is freed and the region returns to default state.
   On success the register is returned, on failure a negative error
   code.
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>PCI Support Library</title>
<!-- drivers/pci/pci.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-bus-max-busnr">pci_bus_max_busnr</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_bus_max_busnr</refname>
 <refpurpose>
   returns maximum PCI bus number of given bus' children
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char __devinit <function>pci_bus_max_busnr </function></funcdef>
   <paramdef>struct pci_bus * <parameter>bus</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
      pointer to PCI bus structure to search
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Given a PCI bus, returns the highest PCI bus number present in the set
   including the given PCI bus and its list of child PCI buses.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-max-busnr">pci_max_busnr</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_max_busnr</refname>
 <refpurpose>
      returns maximum PCI bus number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned char __devinit <function>pci_max_busnr </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   Returns the highest PCI bus number present in the system global list of
   PCI buses.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-find-capability">pci_find_capability</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_find_capability</refname>
 <refpurpose>
      query for devices' capabilities 
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_find_capability </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>cap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      PCI device to query
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cap</parameter></term>
   <listitem>
    <para>
      capability code
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Tell if a device supports a given PCI capability.
   Returns the address of the requested capability structure within the
   device's PCI configuration space or 0 in case the device does not
   support it.  Possible values for <parameter>cap</parameter>:
   </para><para>

   <constant>PCI_CAP_ID_PM</constant>           Power Management 
   <constant>PCI_CAP_ID_AGP</constant>          Accelerated Graphics Port 
   <constant>PCI_CAP_ID_VPD</constant>          Vital Product Data 
   <constant>PCI_CAP_ID_SLOTID</constant>       Slot Identification 
   <constant>PCI_CAP_ID_MSI</constant>          Message Signalled Interrupts
   <constant>PCI_CAP_ID_CHSWP</constant>        CompactPCI HotSwap 
   <constant>PCI_CAP_ID_PCIX</constant>         PCI-X
   <constant>PCI_CAP_ID_EXP</constant>          PCI Express
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-bus-find-capability">pci_bus_find_capability</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_bus_find_capability</refname>
 <refpurpose>
      query for devices' capabilities 
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_bus_find_capability </function></funcdef>
   <paramdef>struct pci_bus * <parameter>bus</parameter></paramdef>
   <paramdef>unsigned int <parameter>devfn</parameter></paramdef>
   <paramdef>int <parameter>cap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
        the PCI bus to query
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>devfn</parameter></term>
   <listitem>
    <para>
      PCI device to query
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cap</parameter></term>
   <listitem>
    <para>
        capability code
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Like <function>pci_find_capability</function> but works for pci devices that do not have a
   pci_dev structure set up yet. 
   </para><para>

   Returns the address of the requested capability structure within the
   device's PCI configuration space or 0 in case the device does not
   support it.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-find-parent-resource">pci_find_parent_resource</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_find_parent_resource</refname>
 <refpurpose>
      return resource region of parent bus of given region
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct resource * <function>pci_find_parent_resource </function></funcdef>
   <paramdef>const struct pci_dev * <parameter>dev</parameter></paramdef>
   <paramdef>struct resource * <parameter>res</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      PCI device structure contains resources to be searched
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>res</parameter></term>
   <listitem>
    <para>
      child resource record for which parent is sought
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   For given resource region of given device, return the resource
   region of parent bus the given region is contained in or where
   it should be allocated from.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-set-power-state">pci_set_power_state</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_set_power_state</refname>
 <refpurpose>
      Set the power state of a PCI device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_set_power_state </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
   <paramdef>pci_power_t <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      PCI device to be suspended
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
      PCI power state (D0, D1, D2, D3hot, D3cold) we're entering
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Transition a device to a new power state, using the Power Management 
   Capabilities in the device's config space.
 </para>
</refsect1>
<refsect1>
 <title>RETURN VALUE</title>
 <para>
    
   -EINVAL if trying to enter a lower state than we're already in.
   0 if we're already in the requested state.
   -EIO if device does not support PCI PM.
   0 if we can successfully change the power state.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-choose-state">pci_choose_state</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_choose_state</refname>
 <refpurpose>
      Choose the power state of a PCI device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>pci_power_t <function>pci_choose_state </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
   <paramdef>u32 <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      PCI device to be suspended
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
      target sleep state for the whole system
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns PCI power state suitable for given device and given system
   message.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-save-state">pci_save_state</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_save_state</refname>
 <refpurpose>
      save the PCI configuration space of a device before suspending
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_save_state </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      - PCI device that we're dealing with
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <parameter>buffer</parameter> must be large enough to hold the entire PCI 2.2 config space 
   (&gt;= 64 bytes).
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-restore-state">pci_restore_state</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_restore_state</refname>
 <refpurpose>
      Restore the saved state of a PCI device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_restore_state </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      - PCI device that we're dealing with
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-enable-device-bars">pci_enable_device_bars</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_enable_device_bars</refname>
 <refpurpose>
      Initialize some of a device for use
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_enable_device_bars </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>bars</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      PCI device to be initialized
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bars</parameter></term>
   <listitem>
    <para>
      bitmask of BAR's that must be configured
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Initialize device before it's used by a driver. Ask low-level code
   to enable selected I/O and memory resources. Wake up the device if it 
   was suspended. Beware, this function can fail.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-enable-device">pci_enable_device</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_enable_device</refname>
 <refpurpose>
      Initialize device before it's used by a driver.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_enable_device </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      PCI device to be initialized
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Initialize device before it's used by a driver. Ask low-level code
   to enable I/O and memory. Wake up the device if it was suspended.
   Beware, this function can fail.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-disable-device">pci_disable_device</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_disable_device</refname>
 <refpurpose>
      Disable PCI device after use
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>pci_disable_device </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      PCI device to be disabled
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Signal to the system that the PCI device is not in use by the system
   anymore.  This only involves disabling PCI bus-mastering, if active.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-enable-wake">pci_enable_wake</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_enable_wake</refname>
 <refpurpose>
      enable device to generate PME# when suspended
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_enable_wake </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
   <paramdef>pci_power_t <parameter>state</parameter></paramdef>
   <paramdef>int <parameter>enable</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      - PCI device to operate on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
      - Current state of device.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>enable</parameter></term>
   <listitem>
    <para>
      - Flag to enable or disable generation
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Set the bits in the device's PM Capabilities to generate PME# when
   the system is suspended. 
   </para><para>

   -EIO is returned if device doesn't have PM Capabilities. 
   -EINVAL is returned if device supports it, but can't generate wake events.
   0 if operation is successful.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-release-region">pci_release_region</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_release_region</refname>
 <refpurpose>
      Release a PCI bar
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>pci_release_region </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
   <paramdef>int <parameter>bar</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
      PCI device whose resources were previously reserved by pci_request_region
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bar</parameter></term>
   <listitem>
    <para>
      BAR to release
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Releases the PCI I/O and memory resources previously reserved by a
   successful call to pci_request_region.  Call this function only
   after all use of the PCI regions has ceased.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-request-region">pci_request_region</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_request_region</refname>
 <refpurpose>
      Reserved PCI I/O and memory resource
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_request_region </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
   <paramdef>int <parameter>bar</parameter></paramdef>
   <paramdef>char * <parameter>res_name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
      PCI device whose resources are to be reserved
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bar</parameter></term>
   <listitem>
    <para>
      BAR to be reserved
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>res_name</parameter></term>
   <listitem>
    <para>
      Name to be associated with resource.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Mark the PCI region associated with PCI device <parameter>pdev</parameter> BR <parameter>bar</parameter> as
   being reserved by owner <parameter>res_name</parameter>.  Do not access any
   address inside the PCI regions unless this call returns
   successfully.
   </para><para>

   Returns 0 on success, or <constant>EBUSY</constant> on error.  A warning
   message is also printed on failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-release-regions">pci_release_regions</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_release_regions</refname>
 <refpurpose>
      Release reserved PCI I/O and memory resources
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>pci_release_regions </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
      PCI device whose resources were previously reserved by pci_request_regions
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Releases all PCI I/O and memory resources previously reserved by a
   successful call to pci_request_regions.  Call this function only
   after all use of the PCI regions has ceased.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-request-regions">pci_request_regions</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_request_regions</refname>
 <refpurpose>
      Reserved PCI I/O and memory resources
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_request_regions </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
   <paramdef>char * <parameter>res_name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
      PCI device whose resources are to be reserved
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>res_name</parameter></term>
   <listitem>
    <para>
      Name to be associated with resource.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Mark all PCI regions associated with PCI device <parameter>pdev</parameter> as
   being reserved by owner <parameter>res_name</parameter>.  Do not access any
   address inside the PCI regions unless this call returns
   successfully.
   </para><para>

   Returns 0 on success, or <constant>EBUSY</constant> on error.  A warning
   message is also printed on failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-set-master">pci_set_master</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_set_master</refname>
 <refpurpose>
      enables bus-mastering for device dev
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>pci_set_master </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      the PCI device to enable
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Enables bus-mastering on the device and calls <function>pcibios_set_master</function>
   to do the needed arch specific settings.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-set-mwi">pci_set_mwi</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_set_mwi</refname>
 <refpurpose>
      enables memory-write-invalidate PCI transaction
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_set_mwi </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      the PCI device for which MWI is enabled
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Enables the Memory-Write-Invalidate transaction in <constant>PCI_COMMAND</constant>,
   and then calls <parameter>pcibios_set_mwi</parameter> to do the needed arch specific
   operations or a generic mwi-prep function.
 </para>
</refsect1>
<refsect1>
 <title>RETURNS</title>
 <para>
    An appropriate -ERRNO error value on error, or zero for success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-clear-mwi">pci_clear_mwi</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_clear_mwi</refname>
 <refpurpose>
      disables Memory-Write-Invalidate for device dev
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>pci_clear_mwi </function></funcdef>
   <paramdef>struct pci_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      the PCI device to disable
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Disables PCI Memory-Write-Invalidate transaction on the device
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>PCI Hotplug Support Library</title>
<!-- drivers/pci/hotplug/pci_hotplug_core.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-hp-register">pci_hp_register</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_hp_register</refname>
 <refpurpose>
   register a hotplug_slot with the PCI hotplug subsystem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_hp_register </function></funcdef>
   <paramdef>struct hotplug_slot * <parameter>slot</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>slot</parameter></term>
   <listitem>
    <para>
      pointer to the &amp;struct hotplug_slot to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Registers a hotplug slot with the pci hotplug subsystem, which will allow
   userspace interaction to the slot.
   </para><para>

   Returns 0 if successful, anything else for an error.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-hp-deregister">pci_hp_deregister</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_hp_deregister</refname>
 <refpurpose>
      deregister a hotplug_slot with the PCI hotplug subsystem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_hp_deregister </function></funcdef>
   <paramdef>struct hotplug_slot * <parameter>slot</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>slot</parameter></term>
   <listitem>
    <para>
      pointer to the &amp;struct hotplug_slot to deregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The <parameter>slot</parameter> must have been registered with the pci hotplug subsystem
   previously with a call to <function>pci_hp_register</function>.
   </para><para>

   Returns 0 if successful, anything else for an error.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pci-hp-change-slot-info">pci_hp_change_slot_info</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pci_hp_change_slot_info</refname>
 <refpurpose>
      changes the slot's information structure in the core
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pci_hp_change_slot_info </function></funcdef>
   <paramdef>struct hotplug_slot * <parameter>slot</parameter></paramdef>
   <paramdef>struct hotplug_slot_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>slot</parameter></term>
   <listitem>
    <para>
      pointer to the slot whose info has changed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
      pointer to the info copy into the slot's info structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <parameter>slot</parameter> must have been registered with the pci 
   hotplug subsystem previously with a call to <function>pci_hp_register</function>.
   </para><para>

   Returns 0 if successful, anything else for an error.
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>MCA Architecture</title>
	<sect2><title>MCA Device Functions</title>
           <para>
              Refer to the file arch/i386/kernel/mca.c for more information.
           </para>
<!-- FIXME: Removed for now since no structured comments in source
X!Earch/i386/kernel/mca.c
-->
	</sect2>
	<sect2><title>MCA Bus DMA</title>
<!-- include/asm-i386/mca_dma.h -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-mca-enable-dma">mca_enable_dma</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mca_enable_dma</refname>
 <refpurpose>
  	channel to enable DMA on
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mca_enable_dma </function></funcdef>
   <paramdef>unsigned int <parameter>dmanr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmanr</parameter></term>
   <listitem>
    <para>
      DMA channel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Enable the MCA bus DMA on a channel. This can be called from
   IRQ context.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mca-disable-dma">mca_disable_dma</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mca_disable_dma</refname>
 <refpurpose>
     	channel to disable DMA on
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mca_disable_dma </function></funcdef>
   <paramdef>unsigned int <parameter>dmanr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmanr</parameter></term>
   <listitem>
    <para>
      DMA channel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Enable the MCA bus DMA on a channel. This can be called from
   IRQ context.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mca-set-dma-addr">mca_set_dma_addr</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mca_set_dma_addr</refname>
 <refpurpose>
     	load a 24bit DMA address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mca_set_dma_addr </function></funcdef>
   <paramdef>unsigned int <parameter>dmanr</parameter></paramdef>
   <paramdef>unsigned int <parameter>a</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmanr</parameter></term>
   <listitem>
    <para>
      DMA channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>a</parameter></term>
   <listitem>
    <para>
      24bit bus address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Load the address register in the DMA controller. This has a 24bit
   limitation (16Mb). 
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mca-get-dma-addr">mca_get_dma_addr</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mca_get_dma_addr</refname>
 <refpurpose>
     	load a 24bit DMA address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>mca_get_dma_addr </function></funcdef>
   <paramdef>unsigned int <parameter>dmanr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmanr</parameter></term>
   <listitem>
    <para>
      DMA channel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Read the address register in the DMA controller. This has a 24bit
   limitation (16Mb). The return is a bus address.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mca-set-dma-count">mca_set_dma_count</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mca_set_dma_count</refname>
 <refpurpose>
     	load a 16bit transfer count
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mca_set_dma_count </function></funcdef>
   <paramdef>unsigned int <parameter>dmanr</parameter></paramdef>
   <paramdef>unsigned int <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmanr</parameter></term>
   <listitem>
    <para>
      DMA channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
      count
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Set the DMA count for this channel. This can be up to 64Kbytes.
   Setting a count of zero will not do what you expect.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mca-get-dma-residue">mca_get_dma_residue</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mca_get_dma_residue</refname>
 <refpurpose>
     	get the remaining bytes to transfer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>mca_get_dma_residue </function></funcdef>
   <paramdef>unsigned int <parameter>dmanr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmanr</parameter></term>
   <listitem>
    <para>
      DMA channel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function returns the number of bytes left to transfer
   on this DMA channel.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mca-set-dma-io">mca_set_dma_io</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mca_set_dma_io</refname>
 <refpurpose>
     	set the port for an I/O transfer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mca_set_dma_io </function></funcdef>
   <paramdef>unsigned int <parameter>dmanr</parameter></paramdef>
   <paramdef>unsigned int <parameter>io_addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmanr</parameter></term>
   <listitem>
    <para>
      DMA channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>io_addr</parameter></term>
   <listitem>
    <para>
      an I/O port number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Unlike the ISA bus DMA controllers the DMA on MCA bus can transfer
   with an I/O port target.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mca-set-dma-mode">mca_set_dma_mode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mca_set_dma_mode</refname>
 <refpurpose>
     	set the DMA mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mca_set_dma_mode </function></funcdef>
   <paramdef>unsigned int <parameter>dmanr</parameter></paramdef>
   <paramdef>unsigned int <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmanr</parameter></term>
   <listitem>
    <para>
      DMA channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      mode to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The DMA controller supports several modes. The mode values you can
 </para>
</refsect1>
<refsect1>
 <title>set are </title>
 <para>
   </para><para>

   <constant>MCA_DMA_MODE_READ</constant> when reading from the DMA device.
   </para><para>

   <constant>MCA_DMA_MODE_WRITE</constant> to writing to the DMA device.
   </para><para>

   <constant>MCA_DMA_MODE_IO</constant> to do DMA to or from an I/O port.
   </para><para>

   <constant>MCA_DMA_MODE_16</constant> to do 16bit transfers.
 </para>
</refsect1>
</refentry>

	</sect2>
     </sect1>
  </chapter>

  <chapter id="devfs">
     <title>The Device File System</title>
<!-- fs/devfs/base.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-devfs-mk-dir">devfs_mk_dir</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>devfs_mk_dir</refname>
 <refpurpose>
   Create a directory in the devfs namespace.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>devfs_mk_dir </function></funcdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
      The name of the entry.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Use of this function is optional. The <function>devfs_register</function> function
   will automatically create intermediate directories as needed. This function
   is provided for efficiency reasons, as it provides a handle to a directory.
   On failure <constant>NULL</constant> is returned.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Use of this function is optional. The <function>devfs_register</function> function
   will automatically create intermediate directories as needed. This function
   is provided for efficiency reasons, as it provides a handle to a directory.
   On failure <constant>NULL</constant> is returned.
 </para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="security">
     <title>Security Framework</title>
<!-- security/security.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-security">register_security</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_security</refname>
 <refpurpose>
   registers a security framework with the kernel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_security </function></funcdef>
   <paramdef>struct security_operations * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
      a pointer to the struct security_options that is to be registered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function is to allow a security module to register itself with the
   kernel security subsystem.  Some rudimentary checking is done on the <parameter>ops</parameter>
   value passed to this function.  A call to <function>unregister_security</function> should be
   done to remove this security_options structure from the kernel.
   </para><para>

   If there is already a security module registered with the kernel,
   an error will be returned.  Otherwise 0 is returned on success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-unregister-security">unregister_security</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>unregister_security</refname>
 <refpurpose>
      unregisters a security framework with the kernel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>unregister_security </function></funcdef>
   <paramdef>struct security_operations * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
      a pointer to the struct security_options that is to be registered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function removes a struct security_operations variable that had
   previously been registered with a successful call to <function>register_security</function>.
   </para><para>

   If <parameter>ops</parameter> does not match the valued previously passed to <function>register_security</function>
   an error is returned.  Otherwise the default security options is set to the
   the dummy_security_ops structure, and 0 is returned.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mod-reg-security">mod_reg_security</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mod_reg_security</refname>
 <refpurpose>
      allows security modules to be <quote>stacked</quote>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mod_reg_security </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct security_operations * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      a pointer to a string with the name of the security_options to be registered
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
      a pointer to the struct security_options that is to be registered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function allows security modules to be stacked if the currently loaded
   security module allows this to happen.  It passes the <parameter>name</parameter> and <parameter>ops</parameter> to the
   register_security function of the currently loaded security module.
   </para><para>

   The return value depends on the currently loaded security module, with 0 as
   success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mod-unreg-security">mod_unreg_security</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mod_unreg_security</refname>
 <refpurpose>
      allows a security module registered with <function>mod_reg_security</function> to be unloaded
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mod_unreg_security </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct security_operations * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
      a pointer to a string with the name of the security_options to be removed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
      a pointer to the struct security_options that is to be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function allows security modules that have been successfully registered
   with a call to <function>mod_reg_security</function> to be unloaded from the system.
   This calls the currently loaded security module's <function>unregister_security</function> call
   with the <parameter>name</parameter> and <parameter>ops</parameter> variables.
   </para><para>

   The return value depends on the currently loaded security module, with 0 as
   success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-capable">capable</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>capable</refname>
 <refpurpose>
      calls the currently loaded security module's <function>capable</function> function with the specified capability
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>capable </function></funcdef>
   <paramdef>int <parameter>cap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cap</parameter></term>
   <listitem>
    <para>
      the requested capability level.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function calls the currently loaded security module's <function>capable</function>
   function with a pointer to the current task and the specified <parameter>cap</parameter> value.
   </para><para>

   This allows the security module to implement the capable function call
   however it chooses to.
 </para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="pmfuncs">
     <title>Power Management</title>
<!-- kernel/power/pm.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-pm-register">pm_register</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pm_register</refname>
 <refpurpose>
   register a device with power management
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct pm_dev * <function>pm_register </function></funcdef>
   <paramdef>pm_dev_t <parameter>type</parameter></paramdef>
   <paramdef>unsigned long <parameter>id</parameter></paramdef>
   <paramdef>pm_callback <parameter>callback</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
      device type 
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
      device ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>callback</parameter></term>
   <listitem>
    <para>
      callback function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Add a device to the list of devices that wish to be notified about
   power management events. A &amp;pm_dev structure is returned on success,
   on failure the return is <constant>NULL</constant>.
   </para><para>

   The callback function will be called in process context and
   it may sleep.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pm-unregister">pm_unregister</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pm_unregister</refname>
 <refpurpose>
       unregister a device with power management
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>pm_unregister </function></funcdef>
   <paramdef>struct pm_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      device to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Remove a device from the power management notification lists. The
   dev passed must be a handle previously returned by pm_register.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pm-unregister-all">pm_unregister_all</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pm_unregister_all</refname>
 <refpurpose>
      unregister all devices with matching callback
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>pm_unregister_all </function></funcdef>
   <paramdef>pm_callback <parameter>callback</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>callback</parameter></term>
   <listitem>
    <para>
      callback function pointer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Unregister every device that would call the callback passed. This
   is primarily meant as a helper function for loadable modules. It
   enables a module to give up all its managed devices without keeping
   its own private list.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-pm-send-all">pm_send_all</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>pm_send_all</refname>
 <refpurpose>
      send request to all managed devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pm_send_all </function></funcdef>
   <paramdef>pm_request_t <parameter>rqst</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rqst</parameter></term>
   <listitem>
    <para>
      power management request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
      data for the callback
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Issue a power management request to a all devices. The 
   <constant>PM_SUSPEND</constant> events are handled specially. Any device is 
   permitted to fail a suspend by returning a non zero (error)
   value from its callback function. If any device vetoes a 
   suspend request then all other devices that have suspended 
   during the processing of this request are restored to their
   previous state.
 </para>
</refsect1>
<refsect1>
 <title>WARNING</title>
 <para>
     This function takes the pm_devs_lock. The lock is not dropped until
   the callbacks have completed. This prevents races against pm locking
   functions, races against module unload pm_unregister code. It does
   mean however that you must not issue pm_ functions within the callback
   or you will deadlock and users will hate you.
   </para><para>

   Zero is returned on success. If a suspend fails then the status
   from the device that vetoes the suspend is returned.
 </para>
</refsect1>
<refsect1>
 <title>BUGS</title>
 <para>
    what stops two power management requests occurring in parallel
   and conflicting.
 </para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="blkdev">
     <title>Block Devices</title>
<!-- drivers/block/ll_rw_blk.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-get-backing-dev-info">blk_get_backing_dev_info</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_get_backing_dev_info</refname>
 <refpurpose>
   get the address of a queue's backing_dev_info
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct backing_dev_info * <function>blk_get_backing_dev_info </function></funcdef>
   <paramdef>struct block_device * <parameter>bdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bdev</parameter></term>
   <listitem>
    <para>
     	device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Locates the passed device's request queue and returns the address of its
   backing_dev_info
   </para><para>

   Will return NULL if the request queue cannot be located.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-prep-rq">blk_queue_prep_rq</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_prep_rq</refname>
 <refpurpose>
      set a prepare_request function for queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_prep_rq </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>prep_rq_fn * <parameter>pfn</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     		queue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pfn</parameter></term>
   <listitem>
    <para>
     	prepare_request function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   It's possible for a queue to register a prepare_request callback which
   is invoked before the request is handed to the request_fn. The goal of
   the function is to prepare a request for I/O, it can be used to build a
   cdb from the request data for instance.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-merge-bvec">blk_queue_merge_bvec</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_merge_bvec</refname>
 <refpurpose>
      set a merge_bvec function for queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_merge_bvec </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>merge_bvec_fn * <parameter>mbfn</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     		queue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mbfn</parameter></term>
   <listitem>
    <para>
     	merge_bvec_fn
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Usually queues have static limitations on the max sectors or segments that
   we can put in a request. Stacking drivers may have some settings that
   are dynamic, and thus we have to query the queue whether it is ok to
   add a new bio_vec to a bio at a given offset or not. If the block device
   has such limitations, it needs to register a merge_bvec_fn to control
   the size of bio's sent to it. Note that a block device *must* allow a
   single page to be added to an empty bio. The block device driver may want
   to use the <function>bio_split</function> function to deal with these bio's. By default
   no merge_bvec_fn is defined for a queue, and only the fixed limits are
   honored.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-make-request">blk_queue_make_request</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_make_request</refname>
 <refpurpose>
      define an alternate make_request function for a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_make_request </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>make_request_fn * <parameter>mfn</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device to be affected
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mfn</parameter></term>
   <listitem>
    <para>
      the alternate make_request function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The normal way for &amp;struct bios to be passed to a device
   driver is for them to be collected into requests on a request
   queue, and then to allow the device driver to select requests
   off that queue when it is ready.  This works well for many block
   devices. However some block devices (typically virtual devices
   such as md or lvm) do not benefit from the processing on the
   request queue, and are served best by having the requests passed
   directly to them.  This can be achieved by providing a function
   to <function>blk_queue_make_request</function>.
 </para>
</refsect1>
<refsect1>
 <title>Caveat</title>
 <para>
   The driver that does this *must* be able to deal appropriately
   with buffers in <quote>highmemory</quote>. This can be accomplished by either calling
   <function>__bio_kmap_atomic</function> to get a temporary kernel mapping, or by calling
   <function>blk_queue_bounce</function> to create a buffer in normal memory.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-ordered">blk_queue_ordered</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_ordered</refname>
 <refpurpose>
      does this queue support ordered writes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_ordered </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>int <parameter>flag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
          the request queue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flag</parameter></term>
   <listitem>
    <para>
       see below
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   For journalled file systems, doing ordered writes on a commit
   block instead of explicitly doing wait_on_buffer (which is bad
   for performance) can be a big win. Block drivers supporting this
   feature should call this function and indicate so.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-issue-flush-fn">blk_queue_issue_flush_fn</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_issue_flush_fn</refname>
 <refpurpose>
      set function for issuing a flush
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_issue_flush_fn </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>issue_flush_fn * <parameter>iff</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
          the request queue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iff</parameter></term>
   <listitem>
    <para>
        the function to be called issuing the flush
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If a driver supports issuing a flush command, the support is notified
   to the block layer by defining it through this call.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-bounce-limit">blk_queue_bounce_limit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_bounce_limit</refname>
 <refpurpose>
      set bounce buffer limit for queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_bounce_limit </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>u64 <parameter>dma_addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_addr</parameter></term>
   <listitem>
    <para>
        bus address limit
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Different hardware can have different requirements as to what pages
   it can do I/O directly to. A low level driver can call
   blk_queue_bounce_limit to have lower memory pages allocated as bounce
   buffers for doing I/O to pages residing above <parameter>page</parameter>. By default
   the block layer sets this to the highest numbered <quote>low</quote> memory page.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-max-sectors">blk_queue_max_sectors</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_max_sectors</refname>
 <refpurpose>
      set max sectors for a request for this queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_max_sectors </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>unsigned short <parameter>max_sectors</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_sectors</parameter></term>
   <listitem>
    <para>
       max sectors in the usual 512b unit
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Enables a low level driver to set an upper limit on the size of
   received requests.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-max-phys-segments">blk_queue_max_phys_segments</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_max_phys_segments</refname>
 <refpurpose>
      set max phys segments for a request for this queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_max_phys_segments </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>unsigned short <parameter>max_segments</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_segments</parameter></term>
   <listitem>
    <para>
       max number of segments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Enables a low level driver to set an upper limit on the number of
   physical data segments in a request.  This would be the largest sized
   scatter list the driver could handle.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-max-hw-segments">blk_queue_max_hw_segments</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_max_hw_segments</refname>
 <refpurpose>
      set max hw segments for a request for this queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_max_hw_segments </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>unsigned short <parameter>max_segments</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_segments</parameter></term>
   <listitem>
    <para>
       max number of segments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Enables a low level driver to set an upper limit on the number of
   hw data segments in a request.  This would be the largest number of
   address/length pairs the host adapter can actually give as once
   to the device.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-max-segment-size">blk_queue_max_segment_size</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_max_segment_size</refname>
 <refpurpose>
      set max segment size for blk_rq_map_sg
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_max_segment_size </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>unsigned int <parameter>max_size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_size</parameter></term>
   <listitem>
    <para>
       max size of segment in bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Enables a low level driver to set an upper limit on the size of a
   coalesced segment
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-hardsect-size">blk_queue_hardsect_size</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_hardsect_size</refname>
 <refpurpose>
      set hardware sector size for the queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_hardsect_size </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>unsigned short <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
       the hardware sector size, in bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This should typically be set to the lowest possible sector size
   that the hardware can operate on (possible without reverting to
   even internal read-modify-write operations). Usually the default
   of 512 covers most hardware.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-stack-limits">blk_queue_stack_limits</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_stack_limits</refname>
 <refpurpose>
      inherit underlying queue limits for stacked drivers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_stack_limits </function></funcdef>
   <paramdef>request_queue_t * <parameter>t</parameter></paramdef>
   <paramdef>request_queue_t * <parameter>b</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>t</parameter></term>
   <listitem>
    <para>
     	the stacking driver (top)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>b</parameter></term>
   <listitem>
    <para>
       the underlying device (bottom)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-segment-boundary">blk_queue_segment_boundary</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_segment_boundary</refname>
 <refpurpose>
      set boundary rules for segment merging
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_segment_boundary </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>unsigned long <parameter>mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mask</parameter></term>
   <listitem>
    <para>
       the memory boundary mask
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-dma-alignment">blk_queue_dma_alignment</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_dma_alignment</refname>
 <refpurpose>
      set dma length and memory alignment
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_dma_alignment </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>int <parameter>mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
          the request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mask</parameter></term>
   <listitem>
    <para>
       alignment mask
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>description</title>
 <para>
   set required memory and length aligment for direct dma transactions.
   this is used when buiding direct io requests for the queue.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-find-tag">blk_queue_find_tag</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_find_tag</refname>
 <refpurpose>
      find a request by its tag and queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct request * <function>blk_queue_find_tag </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>int <parameter>tag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     	 The request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tag</parameter></term>
   <listitem>
    <para>
      The tag of the request
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
 </para>
</refsect1>
<refsect1>
 <title>Notes</title>
 <para>
   Should be used when a device returns a tag and you want to match
   it with a request.
   </para><para>

   no locks need be held.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-free-tags">blk_queue_free_tags</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_free_tags</refname>
 <refpurpose>
      release tag maintenance info
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_free_tags </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Notes</title>
 <para>
   This is used to disabled tagged queuing to a device, yet leave
   queue in function.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-init-tags">blk_queue_init_tags</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_init_tags</refname>
 <refpurpose>
      initialize the queue tag info
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>blk_queue_init_tags </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>int <parameter>depth</parameter></paramdef>
   <paramdef>struct blk_queue_tag * <parameter>tags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>depth</parameter></term>
   <listitem>
    <para>
       the maximum queue depth supported
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tags</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-resize-tags">blk_queue_resize_tags</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_resize_tags</refname>
 <refpurpose>
      change the queueing depth
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>blk_queue_resize_tags </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>int <parameter>new_depth</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_depth</parameter></term>
   <listitem>
    <para>
      the new max command queueing depth
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Notes</title>
 <para>
   Must be called with the queue lock held.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-end-tag">blk_queue_end_tag</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_end_tag</refname>
 <refpurpose>
      end tag operations for a request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_end_tag </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>struct request * <parameter>rq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rq</parameter></term>
   <listitem>
    <para>
      the request that has completed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Typically called when <function>end_that_request_first</function> returns 0, meaning
   all transfers have been done for a request. It's important to call
   this function before <function>end_that_request_last</function>, as that will put the
   request back on the free list thus corrupting the internal tag list.
 </para>
</refsect1>
<refsect1>
 <title>Notes</title>
 <para>
   queue lock must be held.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-start-tag">blk_queue_start_tag</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_start_tag</refname>
 <refpurpose>
      find a free tag and assign it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>blk_queue_start_tag </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>struct request * <parameter>rq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rq</parameter></term>
   <listitem>
    <para>
       the block request that needs tagging
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This can either be used as a stand-alone helper, or possibly be
   assigned as the queue &amp;prep_rq_fn (in which case &amp;struct request
   automagically gets a tag assigned). Note that this function
   assumes that any type of request can be queued! if this is not
   true for your device, you must check the request type before
   calling this function.  The request will also be removed from
   the request queue, so it's the drivers responsibility to readd
   it if it should need to be restarted for some reason.
 </para>
</refsect1>
<refsect1>
 <title>Notes</title>
 <para>
   queue lock must be held.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-queue-invalidate-tags">blk_queue_invalidate_tags</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_queue_invalidate_tags</refname>
 <refpurpose>
      invalidate all pending tags
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_queue_invalidate_tags </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
       the request queue for the device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Hardware conditions may dictate a need to stop all pending requests.
   In this case, we will safely clear the block side of the tag queue and
   readd all requests to the request queue in the right order.
 </para>
</refsect1>
<refsect1>
 <title>Notes</title>
 <para>
   queue lock must be held.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-generic-unplug-device">generic_unplug_device</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>generic_unplug_device</refname>
 <refpurpose>
      fire a request queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>generic_unplug_device </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
         The &amp;request_queue_t in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Linux uses plugging to build bigger requests queues before letting
   the device have at them. If a queue is plugged, the I/O scheduler
   is still adding and merging requests on the queue. Once the queue
   gets unplugged, the request_fn defined for the queue is invoked and
   transfers started.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-start-queue">blk_start_queue</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_start_queue</refname>
 <refpurpose>
      restart a previously stopped queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_start_queue </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
         The &amp;request_queue_t in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>blk_start_queue</function> will clear the stop flag on the queue, and call
   the request_fn for the queue if it was in a stopped state when
   entered. Also see <function>blk_stop_queue</function>. Queue lock must be held.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-stop-queue">blk_stop_queue</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_stop_queue</refname>
 <refpurpose>
      stop a queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_stop_queue </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
         The &amp;request_queue_t in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The Linux block layer assumes that a block driver will consume all
   entries on the request queue when the request_fn strategy is called.
   Often this will not happen, because of hardware limitations (queue
   depth settings). If a device driver gets a 'queue full' response,
   or if it simply chooses not to queue more I/O at one point, it can
   call this function to prevent the request_fn from being called until
   the driver has signalled it's ready to go again. This happens by calling
   <function>blk_start_queue</function> to restart queue operations. Queue lock must be held.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-sync-queue">blk_sync_queue</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_sync_queue</refname>
 <refpurpose>
      cancel any pending callbacks on a queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_sync_queue </function></funcdef>
   <paramdef>struct request_queue * <parameter>q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
      the queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The block layer may perform asynchronous callback activity
   on a queue, such as calling the unplug function after a timeout.
   A block device may call blk_sync_queue to ensure that any
   such activity is cancelled, thus allowing it to release resources
   the the callbacks might use. The caller must already have made sure
   that its -&gt;make_request_fn will not re-add plugging prior to calling
   this function.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-run-queue">blk_run_queue</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_run_queue</refname>
 <refpurpose>
      run a single device queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_run_queue </function></funcdef>
   <paramdef>struct request_queue * <parameter>q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     	The queue to run
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-cleanup-queue">blk_cleanup_queue</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_cleanup_queue</refname>
 <refpurpose>
      release a <structname>request_queue_t</structname> when it is no longer needed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_cleanup_queue </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
         the request queue to be released
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   blk_cleanup_queue is the pair to <function>blk_init_queue</function> or
   <function>blk_queue_make_request</function>.  It should be called when a request queue is
   being released; typically when a block device is being de-registered.
   Currently, its primary task it to free all the &amp;struct request
   structures that were allocated to the queue and the queue itself.
 </para>
</refsect1>
<refsect1>
 <title>Caveat</title>
 <para>
   Hopefully the low level driver will have finished any
   outstanding requests first...
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-init-queue">blk_init_queue</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_init_queue</refname>
 <refpurpose>
      prepare a request queue for use with a block device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>request_queue_t * <function>blk_init_queue </function></funcdef>
   <paramdef>request_fn_proc * <parameter>rfn</parameter></paramdef>
   <paramdef>spinlock_t * <parameter>lock</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rfn</parameter></term>
   <listitem>
    <para>
       The function to be called to process requests that have been
     placed on the queue.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lock</parameter></term>
   <listitem>
    <para>
      Request queue spin lock
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If a block device wishes to use the standard request handling procedures,
   which sorts requests and coalesces adjacent requests, then it must
   call <function>blk_init_queue</function>.  The function <parameter>rfn</parameter> will be called when there
   are requests on the queue that need to be processed.  If the device
   supports plugging, then <parameter>rfn</parameter> may not be called immediately when requests
   are available on the queue, but may be called at some time later instead.
   Plugged queues are generally unplugged when a buffer belonging to one
   of the requests on the queue is needed, or due to memory pressure.
   </para><para>

   <parameter>rfn</parameter> is not required, or even expected, to remove all requests off the
   queue, but only as many as it can handle at a time.  If it does leave
   requests on the queue, it is responsible for arranging that the requests
   get dealt with eventually.
   </para><para>

   The queue spin lock must be held while manipulating the requests on the
   request queue.
   </para><para>

   Function returns a pointer to the initialized request queue, or NULL if
   it didn't succeed.
 </para>
</refsect1>
<refsect1>
 <title>Note</title>
 <para>
   <function>blk_init_queue</function> must be paired with a <function>blk_cleanup_queue</function> call
   when the block device is deactivated (such as at module unload).
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-requeue-request">blk_requeue_request</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_requeue_request</refname>
 <refpurpose>
      put a request back on queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_requeue_request </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>struct request * <parameter>rq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     		request queue where request should be inserted
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rq</parameter></term>
   <listitem>
    <para>
     		request to be inserted
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Drivers often keep queueing requests until the hardware cannot accept
   more, when that condition happens we need to put the request back
   on the queue. Must be called with queue lock held.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-insert-request">blk_insert_request</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_insert_request</refname>
 <refpurpose>
      insert a special request in to a request queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_insert_request </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>struct request * <parameter>rq</parameter></paramdef>
   <paramdef>int <parameter>at_head</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int <parameter>reinsert</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     		request queue where request should be inserted
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rq</parameter></term>
   <listitem>
    <para>
     		request to be inserted
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>at_head</parameter></term>
   <listitem>
    <para>
     	insert request at head or tail of queue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     	private data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reinsert</parameter></term>
   <listitem>
    <para>
     	true if request it a reinsertion of previously processed one
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Many block devices need to execute commands asynchronously, so they don't
   block the whole kernel from preemption during request execution.  This is
   accomplished normally by inserting aritficial requests tagged as
   REQ_SPECIAL in to the corresponding request queue, and letting them be
   scheduled for actual execution by the request queue.
   </para><para>

   We have the option of inserting the head or the tail of the queue.
   Typically we use the tail for new ioctls and so forth.  We use the head
   of the queue for things like a QUEUE_FULL message from a device, or a
   host that is unable to accept a particular command.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-rq-map-user">blk_rq_map_user</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_rq_map_user</refname>
 <refpurpose>
      map user data to a request, for REQ_BLOCK_PC usage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct request * <function>blk_rq_map_user </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>int <parameter>rw</parameter></paramdef>
   <paramdef>void __user * <parameter>ubuf</parameter></paramdef>
   <paramdef>unsigned int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     		request queue where request should be inserted
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rw</parameter></term>
   <listitem>
    <para>
     		READ or WRITE data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ubuf</parameter></term>
   <listitem>
    <para>
     	the user buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     	length of user data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Data will be mapped directly for zero copy io, if possible. Otherwise
   a kernel bounce buffer is used.
   </para><para>

   A matching <function>blk_rq_unmap_user</function> must be issued at the end of io, while
   still in process context.
 </para>
</refsect1>
<refsect1>
 <title>Note</title>
 <para>
    The mapped bio may need to be bounced through <function>blk_queue_bounce</function>
   before being submitted to the device, as pages mapped may be out of
   reach. It's the callers responsibility to make sure this happens. The
   original bio must be passed back in to <function>blk_rq_unmap_user</function> for proper
   unmapping.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-rq-unmap-user">blk_rq_unmap_user</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_rq_unmap_user</refname>
 <refpurpose>
      unmap a request with user data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>blk_rq_unmap_user </function></funcdef>
   <paramdef>struct request * <parameter>rq</parameter></paramdef>
   <paramdef>struct bio * <parameter>bio</parameter></paramdef>
   <paramdef>unsigned int <parameter>ulen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rq</parameter></term>
   <listitem>
    <para>
     		request to be unmapped
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bio</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ulen</parameter></term>
   <listitem>
    <para>
     	length of user buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Unmap a request previously mapped by <function>blk_rq_map_user</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-execute-rq">blk_execute_rq</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_execute_rq</refname>
 <refpurpose>
      insert a request into queue for execution
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>blk_execute_rq </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>struct gendisk * <parameter>bd_disk</parameter></paramdef>
   <paramdef>struct request * <parameter>rq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     		queue to insert the request in
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bd_disk</parameter></term>
   <listitem>
    <para>
     	matching gendisk
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rq</parameter></term>
   <listitem>
    <para>
     		request to insert
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Insert a fully prepared request at the back of the io scheduler queue
   for execution.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blkdev-issue-flush">blkdev_issue_flush</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blkdev_issue_flush</refname>
 <refpurpose>
      queue a flush
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>blkdev_issue_flush </function></funcdef>
   <paramdef>struct block_device * <parameter>bdev</parameter></paramdef>
   <paramdef>sector_t * <parameter>error_sector</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bdev</parameter></term>
   <listitem>
    <para>
     	blockdev to issue flush for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>error_sector</parameter></term>
   <listitem>
    <para>
     	error sector
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Issue a flush for the block device in question. Caller can supply
   room for storing the error offset in case of a flush error, if they
   wish to.  Caller must run <function>wait_for_completion</function> on its own.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blkdev-scsi-issue-flush-fn">blkdev_scsi_issue_flush_fn</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blkdev_scsi_issue_flush_fn</refname>
 <refpurpose>
      issue flush for SCSI devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>blkdev_scsi_issue_flush_fn </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>struct gendisk * <parameter>disk</parameter></paramdef>
   <paramdef>sector_t * <parameter>error_sector</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     		device queue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>disk</parameter></term>
   <listitem>
    <para>
     	gendisk
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>error_sector</parameter></term>
   <listitem>
    <para>
     	error offset
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Devices understanding the SCSI command set, can use this function as
   a helper for issuing a cache flush. Note: driver is required to store
   the error offset (in case of error flushing) in -&gt;sector of struct
   request.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-congestion-wait">blk_congestion_wait</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_congestion_wait</refname>
 <refpurpose>
      wait for a queue to become uncongested
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>blk_congestion_wait </function></funcdef>
   <paramdef>int <parameter>rw</parameter></paramdef>
   <paramdef>long <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rw</parameter></term>
   <listitem>
    <para>
      READ or WRITE
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
      timeout in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Waits for up to <parameter>timeout</parameter> jiffies for a queue (any queue) to exit congestion.
   If no queues are congested then just wait for the next request to be
   returned.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-blk-attempt-remerge">blk_attempt_remerge</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>blk_attempt_remerge</refname>
 <refpurpose>
      attempt to remerge active head with next request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>blk_attempt_remerge </function></funcdef>
   <paramdef>request_queue_t * <parameter>q</parameter></paramdef>
   <paramdef>struct request * <parameter>rq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
         The &amp;request_queue_t belonging to the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rq</parameter></term>
   <listitem>
    <para>
        The head request (usually)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   For head-active devices, the queue can easily be unplugged so quickly
   that proper merging is not done on the front request. This may hurt
   performance greatly for some devices. The block layer cannot safely
   do merging on that first request for these queues, but the driver can
   call this function and make it happen any way. Only the driver knows
   when it is safe to do so.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-generic-make-request">generic_make_request</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>generic_make_request</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>generic_make_request </function></funcdef>
   <paramdef>struct bio * <parameter>bio</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bio</parameter></term>
   <listitem>
    <para>
       The bio describing the location in memory and on the device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>generic_make_request</function> is used to make I/O requests of block
   devices. It is passed a &amp;struct bio, which describes the I/O that needs
   to be done.
   </para><para>

   <function>generic_make_request</function> does not return any status.  The
   success/failure status of the request, along with notification of
   completion, is delivered asynchronously through the bio-&gt;bi_end_io
   function described (one day) else where.
   </para><para>

   The caller of generic_make_request must make sure that bi_io_vec
   are set to describe the memory buffer, and that bi_dev and bi_sector are
   set to describe the device address, and the
   bi_end_io and optionally bi_private are set to describe how
   completion notification should be signaled.
   </para><para>

   generic_make_request and the drivers it calls may use bi_next if this
   bio happens to be merged with someone else, and may change bi_dev and
   bi_sector for remaps as it sees fit.  So the values of these fields
   should NOT be depended on after the call to generic_make_request.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-submit-bio">submit_bio</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>submit_bio</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>submit_bio </function></funcdef>
   <paramdef>int <parameter>rw</parameter></paramdef>
   <paramdef>struct bio * <parameter>bio</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rw</parameter></term>
   <listitem>
    <para>
      whether to <constant>READ</constant> or <constant>WRITE</constant>, or maybe to <constant>READA</constant> (read ahead)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bio</parameter></term>
   <listitem>
    <para>
      The &amp;struct bio which describes the I/O
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>submit_bio</function> is very similar in purpose to <function>generic_make_request</function>, and
   uses that function to do most of the work. Both are fairly rough
   interfaces, <parameter>bio</parameter> must be presetup and ready for I/O.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-end-that-request-first">end_that_request_first</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>end_that_request_first</refname>
 <refpurpose>
      end I/O on a request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>end_that_request_first </function></funcdef>
   <paramdef>struct request * <parameter>req</parameter></paramdef>
   <paramdef>int <parameter>uptodate</parameter></paramdef>
   <paramdef>int <parameter>nr_sectors</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
           the request being processed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uptodate</parameter></term>
   <listitem>
    <para>
      1 for success, 0 for I/O error, &lt; 0 for specific error
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nr_sectors</parameter></term>
   <listitem>
    <para>
      number of sectors to end I/O on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Ends I/O on a number of sectors attached to <parameter>req</parameter>, and sets it up
   for the next range of segments (if any) in the cluster.
 </para>
</refsect1>
<refsect1>
 <title>Return</title>
 <para>
   0 - we are done with this request, call <function>end_that_request_last</function>
   1 - still buffers pending for this request
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-end-that-request-chunk">end_that_request_chunk</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>end_that_request_chunk</refname>
 <refpurpose>
      end I/O on a request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>end_that_request_chunk </function></funcdef>
   <paramdef>struct request * <parameter>req</parameter></paramdef>
   <paramdef>int <parameter>uptodate</parameter></paramdef>
   <paramdef>int <parameter>nr_bytes</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
           the request being processed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uptodate</parameter></term>
   <listitem>
    <para>
      1 for success, 0 for I/O error, &lt; 0 for specific error
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nr_bytes</parameter></term>
   <listitem>
    <para>
      number of bytes to complete
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Ends I/O on a number of bytes attached to <parameter>req</parameter>, and sets it up
   for the next range of segments (if any). Like <function>end_that_request_first</function>,
   but deals with bytes instead of sectors.
 </para>
</refsect1>
<refsect1>
 <title>Return</title>
 <para>
   0 - we are done with this request, call <function>end_that_request_last</function>
   1 - still buffers pending for this request
 </para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="miscdev">
     <title>Miscellaneous Devices</title>
<!-- drivers/char/misc.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-misc-register">misc_register</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>misc_register</refname>
 <refpurpose>
  	register a miscellaneous device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>misc_register </function></funcdef>
   <paramdef>struct miscdevice * <parameter>misc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>misc</parameter></term>
   <listitem>
    <para>
      device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Register a miscellaneous device with the kernel. If the minor
   number is set to <constant>MISC_DYNAMIC_MINOR</constant> a minor number is assigned
   and placed in the minor field of the structure. For other cases
   the minor number requested is used.
   </para><para>

   The structure passed is linked into the kernel and may not be
   destroyed until it has been unregistered.
   </para><para>

   A zero is returned on success and a negative errno code for
   failure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-misc-deregister">misc_deregister</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>misc_deregister</refname>
 <refpurpose>
      unregister a miscellaneous device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>misc_deregister </function></funcdef>
   <paramdef>struct miscdevice * <parameter>misc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>misc</parameter></term>
   <listitem>
    <para>
      device to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Unregister a miscellaneous device that was previously
   successfully registered with <function>misc_register</function>. Success
   is indicated by a zero return, a negative errno code
   indicates an error.
 </para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="viddev">
     <title>Video4Linux</title>
<!-- drivers/media/video/videodev.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-video-register-device">video_register_device</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>video_register_device</refname>
 <refpurpose>
   register video4linux devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>video_register_device </function></funcdef>
   <paramdef>struct video_device * <parameter>vfd</parameter></paramdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>int <parameter>nr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vfd</parameter></term>
   <listitem>
    <para>
       video device structure we want to register
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
      type of device to register
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nr</parameter></term>
   <listitem>
    <para>
        which device number (0 == /dev/video0, 1 == /dev/video1, ...
     -1 == first free)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   The registration code assigns minor numbers based on the type
   requested. -ENFILE is returned in all the device slots for this
   category are full. If not then the minor field is set and the
   driver initialize function is called (if non <constant>NULL</constant>).
   </para><para>

   Zero is returned on success.
   </para><para>

   Valid types are
   </para><para>

   <constant>VFL_TYPE_GRABBER</constant> - A frame grabber
   </para><para>

   <constant>VFL_TYPE_VTX</constant> - A teletext device
   </para><para>

   <constant>VFL_TYPE_VBI</constant> - Vertical blank data (undecoded)
   </para><para>

   <constant>VFL_TYPE_RADIO</constant> - A radio card	
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-video-unregister-device">video_unregister_device</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>video_unregister_device</refname>
 <refpurpose>
      unregister a video4linux device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>video_unregister_device </function></funcdef>
   <paramdef>struct video_device * <parameter>vfd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vfd</parameter></term>
   <listitem>
    <para>
      the device to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This unregisters the passed device and deassigns the minor
   number. Future open calls will be met with errors.
 </para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="snddev">
     <title>Sound Devices</title>
<!-- sound/sound_core.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-sound-special">register_sound_special</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_sound_special</refname>
 <refpurpose>
   register a special sound node
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_sound_special </function></funcdef>
   <paramdef>struct file_operations * <parameter>fops</parameter></paramdef>
   <paramdef>int <parameter>unit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fops</parameter></term>
   <listitem>
    <para>
      File operations for the driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>unit</parameter></term>
   <listitem>
    <para>
      Unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocate a special sound device by minor number from the sound
   subsystem. The allocated number is returned on succes. On failure
   a negative error code is returned.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-sound-mixer">register_sound_mixer</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_sound_mixer</refname>
 <refpurpose>
      register a mixer device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_sound_mixer </function></funcdef>
   <paramdef>struct file_operations * <parameter>fops</parameter></paramdef>
   <paramdef>int <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fops</parameter></term>
   <listitem>
    <para>
      File operations for the driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocate a mixer device. Unit is the number of the mixer requested.
   Pass -1 to request the next free mixer unit. On success the allocated
   number is returned, on failure a negative error code is returned.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-sound-midi">register_sound_midi</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_sound_midi</refname>
 <refpurpose>
      register a midi device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_sound_midi </function></funcdef>
   <paramdef>struct file_operations * <parameter>fops</parameter></paramdef>
   <paramdef>int <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fops</parameter></term>
   <listitem>
    <para>
      File operations for the driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocate a midi device. Unit is the number of the midi device requested.
   Pass -1 to request the next free midi unit. On success the allocated
   number is returned, on failure a negative error code is returned.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-sound-dsp">register_sound_dsp</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_sound_dsp</refname>
 <refpurpose>
      register a DSP device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_sound_dsp </function></funcdef>
   <paramdef>struct file_operations * <parameter>fops</parameter></paramdef>
   <paramdef>int <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fops</parameter></term>
   <listitem>
    <para>
      File operations for the driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocate a DSP device. Unit is the number of the DSP requested.
   Pass -1 to request the next free DSP unit. On success the allocated
   number is returned, on failure a negative error code is returned.
   </para><para>

   This function allocates both the audio and dsp device entries together
   and will always allocate them as a matching pair - eg dsp3/audio3
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-sound-synth">register_sound_synth</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_sound_synth</refname>
 <refpurpose>
      register a synth device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_sound_synth </function></funcdef>
   <paramdef>struct file_operations * <parameter>fops</parameter></paramdef>
   <paramdef>int <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fops</parameter></term>
   <listitem>
    <para>
      File operations for the driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocate a synth device. Unit is the number of the synth device requested.
   Pass -1 to request the next free synth unit. On success the allocated
   number is returned, on failure a negative error code is returned.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-unregister-sound-special">unregister_sound_special</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>unregister_sound_special</refname>
 <refpurpose>
      unregister a special sound device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_sound_special </function></funcdef>
   <paramdef>int <parameter>unit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>unit</parameter></term>
   <listitem>
    <para>
      unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Release a sound device that was allocated with
   <function>register_sound_special</function>. The unit passed is the return value from
   the register function.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-unregister-sound-mixer">unregister_sound_mixer</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>unregister_sound_mixer</refname>
 <refpurpose>
      unregister a mixer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_sound_mixer </function></funcdef>
   <paramdef>int <parameter>unit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>unit</parameter></term>
   <listitem>
    <para>
      unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Release a sound device that was allocated with <function>register_sound_mixer</function>.
   The unit passed is the return value from the register function.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-unregister-sound-midi">unregister_sound_midi</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>unregister_sound_midi</refname>
 <refpurpose>
      unregister a midi device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_sound_midi </function></funcdef>
   <paramdef>int <parameter>unit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>unit</parameter></term>
   <listitem>
    <para>
      unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Release a sound device that was allocated with <function>register_sound_midi</function>.
   The unit passed is the return value from the register function.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-unregister-sound-dsp">unregister_sound_dsp</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>unregister_sound_dsp</refname>
 <refpurpose>
      unregister a DSP device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_sound_dsp </function></funcdef>
   <paramdef>int <parameter>unit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>unit</parameter></term>
   <listitem>
    <para>
      unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Release a sound device that was allocated with <function>register_sound_dsp</function>.
   The unit passed is the return value from the register function.
   </para><para>

   Both of the allocated units are released together automatically.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-unregister-sound-synth">unregister_sound_synth</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>unregister_sound_synth</refname>
 <refpurpose>
      unregister a synth device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_sound_synth </function></funcdef>
   <paramdef>int <parameter>unit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>unit</parameter></term>
   <listitem>
    <para>
      unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Release a sound device that was allocated with <function>register_sound_synth</function>.
   The unit passed is the return value from the register function.
 </para>
</refsect1>
</refentry>

<!-- FIXME: Removed for now since no structured comments in source
X!Isound/sound_firmware.c
-->
  </chapter>

  <chapter id="uart16x50">
     <title>16x50 UART Driver</title>
<!-- drivers/serial/serial_core.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-uart-update-timeout">uart_update_timeout</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>uart_update_timeout</refname>
 <refpurpose>
   update per-port FIFO timeout.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>uart_update_timeout </function></funcdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
   <paramdef>unsigned int <parameter>cflag</parameter></paramdef>
   <paramdef>unsigned int <parameter>baud</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
       uart_port structure describing the port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cflag</parameter></term>
   <listitem>
    <para>
      termios cflag value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>baud</parameter></term>
   <listitem>
    <para>
       speed of the port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Set the port FIFO timeout value.  The <parameter>cflag</parameter> value should
   reflect the actual hardware settings.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-uart-get-baud-rate">uart_get_baud_rate</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>uart_get_baud_rate</refname>
 <refpurpose>
      return baud rate for a particular port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>uart_get_baud_rate </function></funcdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
   <paramdef>struct termios * <parameter>termios</parameter></paramdef>
   <paramdef>struct termios * <parameter>old</parameter></paramdef>
   <paramdef>unsigned int <parameter>min</parameter></paramdef>
   <paramdef>unsigned int <parameter>max</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
      uart_port structure describing the port in question.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>termios</parameter></term>
   <listitem>
    <para>
      desired termios settings.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>old</parameter></term>
   <listitem>
    <para>
      old termios (or NULL)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>min</parameter></term>
   <listitem>
    <para>
      minimum acceptable baud rate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max</parameter></term>
   <listitem>
    <para>
      maximum acceptable baud rate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Decode the termios structure into a numeric baud rate,
   taking account of the magic 38400 baud rate (with spd_*
   flags), and mapping the <constant>B0</constant> rate to 9600 baud.
   </para><para>

   If the new baud rate is invalid, try the old termios setting.
   If it's still invalid, we try 9600 baud.
   </para><para>

   Update the <parameter>termios</parameter> structure to reflect the baud rate
   we're actually going to be using.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-uart-get-divisor">uart_get_divisor</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>uart_get_divisor</refname>
 <refpurpose>
      return uart clock divisor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>uart_get_divisor </function></funcdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
   <paramdef>unsigned int <parameter>baud</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
      uart_port structure describing the port.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>baud</parameter></term>
   <listitem>
    <para>
      desired baud rate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Calculate the uart clock divisor for the port.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-uart-register-driver">uart_register_driver</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>uart_register_driver</refname>
 <refpurpose>
      register a driver with the uart core layer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>uart_register_driver </function></funcdef>
   <paramdef>struct uart_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
      low level driver structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Register a uart driver with the core driver.  We in turn register
   with the tty layer, and initialise the core driver per-port state.
   </para><para>

   We have a proc file in /proc/tty/driver which is named after the
   normal driver.
   </para><para>

   drv-&gt;port should be NULL, and the per-port structures should be
   registered using uart_add_one_port after this call has succeeded.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-uart-unregister-driver">uart_unregister_driver</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>uart_unregister_driver</refname>
 <refpurpose>
      remove a driver from the uart core layer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>uart_unregister_driver </function></funcdef>
   <paramdef>struct uart_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
      low level driver structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Remove all references to a driver from the core driver.  The low
   level driver must have removed all its ports via the
   <function>uart_remove_one_port</function> if it registered them with <function>uart_add_one_port</function>.
   (ie, drv-&gt;port == NULL)
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-uart-add-one-port">uart_add_one_port</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>uart_add_one_port</refname>
 <refpurpose>
      attach a driver-defined port structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>uart_add_one_port </function></funcdef>
   <paramdef>struct uart_driver * <parameter>drv</parameter></paramdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
      pointer to the uart low level driver structure for this port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
      uart port structure to use for this port.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This allows the driver to register its own uart_port structure
   with the core driver.  The main purpose is to allow the low
   level uart drivers to expand uart_port, rather than having yet
   more levels of structures.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-uart-remove-one-port">uart_remove_one_port</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>uart_remove_one_port</refname>
 <refpurpose>
      detach a driver defined port structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>uart_remove_one_port </function></funcdef>
   <paramdef>struct uart_driver * <parameter>drv</parameter></paramdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
      pointer to the uart low level driver structure for this port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
      uart port structure for this port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This unhooks (and hangs up) the specified port structure from the
   core driver.  No further calls will be made to the low-level code
   for this port.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-uart-register-port">uart_register_port</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>uart_register_port</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>uart_register_port </function></funcdef>
   <paramdef>struct uart_driver * <parameter>drv</parameter></paramdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
      pointer to the uart low level driver structure for this port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
      uart port structure describing the port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Register UART settings with the specified low level driver.  Detect
   the type of the port if UPF_BOOT_AUTOCONF is set, and detect the
   IRQ if UPF_AUTO_IRQ is set.
   </para><para>

   We try to pick the same port for the same IO base address, so that
   when a modem is plugged in, unplugged and plugged back in, it gets
   allocated the same port.
   </para><para>

   Returns negative error, or positive line number.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-uart-unregister-port">uart_unregister_port</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>uart_unregister_port</refname>
 <refpurpose>
      de-allocate a port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>uart_unregister_port </function></funcdef>
   <paramdef>struct uart_driver * <parameter>drv</parameter></paramdef>
   <paramdef>int <parameter>line</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
      pointer to the uart low level driver structure for this port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>line</parameter></term>
   <listitem>
    <para>
      line index previously returned from <function>uart_register_port</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Hang up the specified line associated with the low level driver,
   and mark the port as unused.
 </para>
</refsect1>
</refentry>

<!-- drivers/serial/8250.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-serial8250-suspend-port">serial8250_suspend_port</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>serial8250_suspend_port</refname>
 <refpurpose>
   suspend one serial port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>serial8250_suspend_port </function></funcdef>
   <paramdef>int <parameter>line</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>line</parameter></term>
   <listitem>
    <para>
       serial line number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Suspend one serial port.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-serial8250-resume-port">serial8250_resume_port</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>serial8250_resume_port</refname>
 <refpurpose>
      resume one serial port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>serial8250_resume_port </function></funcdef>
   <paramdef>int <parameter>line</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>line</parameter></term>
   <listitem>
    <para>
       serial line number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Resume one serial port.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-serial8250-register-port">serial8250_register_port</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>serial8250_register_port</refname>
 <refpurpose>
      register a serial port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>serial8250_register_port </function></funcdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
      serial port template
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Configure the serial port specified by the request. If the
   port exists and is in use, it is hung up and unregistered
   first.
   </para><para>

   The port is then probed and if necessary the IRQ is autodetected
   If this fails an error is returned.
   </para><para>

   On success the port is ready to use and the line number is returned.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-serial8250-unregister-port">serial8250_unregister_port</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>serial8250_unregister_port</refname>
 <refpurpose>
      remove a 16x50 serial port at runtime
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>serial8250_unregister_port </function></funcdef>
   <paramdef>int <parameter>line</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>line</parameter></term>
   <listitem>
    <para>
      serial line number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Remove one serial port.  This may not be called from interrupt
   context.  We hand the port back to the our control.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-serial">register_serial</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_serial</refname>
 <refpurpose>
      configure a 16x50 serial port at runtime
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_serial </function></funcdef>
   <paramdef>struct serial_struct * <parameter>req</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
      request structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Configure the serial port specified by the request. If the
   port exists and is in use an error is returned. If the port
   is not currently in the table it is added.
   </para><para>

   The port is then probed and if necessary the IRQ is autodetected
   If this fails an error is returned.
   </para><para>

   On success the port is ready to use and the line number is returned.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-unregister-serial">unregister_serial</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>unregister_serial</refname>
 <refpurpose>
      remove a 16x50 serial port at runtime
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_serial </function></funcdef>
   <paramdef>int <parameter>line</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>line</parameter></term>
   <listitem>
    <para>
      serial line number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Remove one serial port.  This may not be called from interrupt
   context.  We hand the port back to our local PM control.
 </para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="z85230">
     <title>Z85230 Support Library</title>
<!-- drivers/net/wan/z85230.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-interrupt">z8530_interrupt</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_interrupt</refname>
 <refpurpose>
   Handle an interrupt from a Z8530
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>irqreturn_t <function>z8530_interrupt </function></funcdef>
   <paramdef>int <parameter>irq</parameter></paramdef>
   <paramdef>void * <parameter>dev_id</parameter></paramdef>
   <paramdef>struct pt_regs * <parameter>regs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
      	Interrupt number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev_id</parameter></term>
   <listitem>
    <para>
      The Z8530 device that is interrupting.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>regs</parameter></term>
   <listitem>
    <para>
      unused
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   A Z85[2]30 device has stuck its hand in the air for attention.
   We scan both the channels on the chip for events and then call
   the channel specific call backs for each channel that has events.
   We have to use callback functions because the two channels can be
   in different modes.
   </para><para>

   Locking is done for the handlers. Note that locking is done
   at the chip level (the 5uS delay issue is per chip not per
   channel). c-&gt;lock for both channels points to dev-&gt;lock
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-sync-open">z8530_sync_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_sync_open</refname>
 <refpurpose>
      Open a Z8530 channel for PIO
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>z8530_sync_open </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct z8530_channel * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     	The network interface we are using
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     	The Z8530 channel to open in synchronous PIO mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Switch a Z8530 into synchronous mode without DMA assist. We
   raise the RTS/DTR and commence network operation.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-sync-close">z8530_sync_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_sync_close</refname>
 <refpurpose>
      Close a PIO Z8530 channel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>z8530_sync_close </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct z8530_channel * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Network device to close
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      Z8530 channel to disassociate and move to idle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Close down a Z8530 interface and switch its interrupt handlers
   to discard future events.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-sync-dma-open">z8530_sync_dma_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_sync_dma_open</refname>
 <refpurpose>
      Open a Z8530 for DMA I/O
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>z8530_sync_dma_open </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct z8530_channel * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      The network device to attach
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      The Z8530 channel to configure in sync DMA mode.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Set up a Z85x30 device for synchronous DMA in both directions. Two
   ISA DMA channels must be available for this to work. We assume ISA
   DMA driven I/O and PC limits on access.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-sync-dma-close">z8530_sync_dma_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_sync_dma_close</refname>
 <refpurpose>
      Close down DMA I/O
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>z8530_sync_dma_close </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct z8530_channel * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Network device to detach
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      Z8530 channel to move into discard mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Shut down a DMA mode synchronous interface. Halt the DMA, and
   free the buffers.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-sync-txdma-open">z8530_sync_txdma_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_sync_txdma_open</refname>
 <refpurpose>
      Open a Z8530 for TX driven DMA
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>z8530_sync_txdma_open </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct z8530_channel * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      The network device to attach
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      The Z8530 channel to configure in sync DMA mode.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Set up a Z85x30 device for synchronous DMA tranmission. One
   ISA DMA channel must be available for this to work. The receive
   side is run in PIO mode, but then it has the bigger FIFO.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-sync-txdma-close">z8530_sync_txdma_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_sync_txdma_close</refname>
 <refpurpose>
      Close down a TX driven DMA channel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>z8530_sync_txdma_close </function></funcdef>
   <paramdef>struct net_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct z8530_channel * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Network device to detach
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      Z8530 channel to move into discard mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Shut down a DMA/PIO split mode synchronous interface. Halt the DMA, 
   and  free the buffers.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-describe">z8530_describe</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_describe</refname>
 <refpurpose>
      Uniformly describe a Z8530 port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>z8530_describe </function></funcdef>
   <paramdef>struct z8530_dev * <parameter>dev</parameter></paramdef>
   <paramdef>char * <parameter>mapping</parameter></paramdef>
   <paramdef>unsigned long <parameter>io</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Z8530 device to describe
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mapping</parameter></term>
   <listitem>
    <para>
      string holding mapping type (eg <quote>I/O</quote> or <quote>Mem</quote>)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>io</parameter></term>
   <listitem>
    <para>
      the port value in question
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Describe a Z8530 in a standard format. We must pass the I/O as
   the port offset isnt predictable. The main reason for this function
   is to try and get a common format of report.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-init">z8530_init</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_init</refname>
 <refpurpose>
      Initialise a Z8530 device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>z8530_init </function></funcdef>
   <paramdef>struct z8530_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      Z8530 device to initialise.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Configure up a Z8530/Z85C30 or Z85230 chip. We check the device
   is present, identify the type and then program it to hopefully
   keep quite and behave. This matters a lot, a Z8530 in the wrong
   state will sometimes get into stupid modes generating 10Khz
   interrupt streams and the like.
   </para><para>

   We set the interrupt handler up to discard any events, in case
   we get them during reset or setp.
   </para><para>

   Return 0 for success, or a negative value indicating the problem
   in errno form.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-shutdown">z8530_shutdown</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_shutdown</refname>
 <refpurpose>
      Shutdown a Z8530 device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>z8530_shutdown </function></funcdef>
   <paramdef>struct z8530_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
      The Z8530 chip to shutdown
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   We set the interrupt handlers to silence any interrupts. We then 
   reset the chip and wait 100uS to be sure the reset completed. Just
   in case the caller then tries to do stuff.
   </para><para>

   This is called without the lock held
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-channel-load">z8530_channel_load</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_channel_load</refname>
 <refpurpose>
      Load channel data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>z8530_channel_load </function></funcdef>
   <paramdef>struct z8530_channel * <parameter>c</parameter></paramdef>
   <paramdef>u8 * <parameter>rtable</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      Z8530 channel to configure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rtable</parameter></term>
   <listitem>
    <para>
      table of register, value pairs
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>FIXME</title>
 <para>
    ioctl to allow user uploaded tables
   </para><para>

   Load a Z8530 channel up from the system data. We use +16 to 
   indicate the <quote>prime</quote> registers. The value 255 terminates the
   table.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-null-rx">z8530_null_rx</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_null_rx</refname>
 <refpurpose>
      Discard a packet
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>z8530_null_rx </function></funcdef>
   <paramdef>struct z8530_channel * <parameter>c</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      The channel the packet arrived on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      The buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   We point the receive handler at this function when idle. Instead
   of syncppp processing the frames we get to throw them away.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-queue-xmit">z8530_queue_xmit</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_queue_xmit</refname>
 <refpurpose>
      Queue a packet
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>z8530_queue_xmit </function></funcdef>
   <paramdef>struct z8530_channel * <parameter>c</parameter></paramdef>
   <paramdef>struct sk_buff * <parameter>skb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      The channel to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>skb</parameter></term>
   <listitem>
    <para>
      The packet to kick down the channel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Queue a packet for transmission. Because we have rather
   hard to hit interrupt latencies for the Z85230 per packet 
   even in DMA mode we do the flip to DMA buffer if needed here
   not in the IRQ.
   </para><para>

   Called from the network code. The lock is not held at this 
   point.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-z8530-get-stats">z8530_get_stats</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>z8530_get_stats</refname>
 <refpurpose>
      Get network statistics
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct net_device_stats * <function>z8530_get_stats </function></funcdef>
   <paramdef>struct z8530_channel * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
      The channel to use
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Get the statistics block. We keep the statistics in software as
   the chip doesn't do it for us.
   </para><para>

   Locking is ignored here - we could lock for a copy but its
   not likely to be that big an issue
 </para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="fbdev">
     <title>Frame Buffer Library</title>

     <para>
       The frame buffer drivers depend heavily on four data structures.  
       These structures are declared in include/linux/fb.h.  They are 
       fb_info, fb_var_screeninfo, fb_fix_screeninfo and fb_monospecs. 
       The last three can be made available to and from userland. 
     </para>

     <para>
       fb_info defines the current state of a particular video card. 
       Inside fb_info, there exists a fb_ops structure which is a 
       collection of needed functions to make fbdev and fbcon work.
       fb_info is only visible to the kernel.
     </para>

     <para>
       fb_var_screeninfo is used to describe the features of a video card 
       that are user defined.  With fb_var_screeninfo, things such as
       depth and the resolution may be defined.
     </para>

     <para>
       The next structure is fb_fix_screeninfo. This defines the 
       properties of a card that are created when a mode is set and can't 
       be changed otherwise.  A good example of this is the start of the 
       frame buffer memory.  This "locks" the address of the frame buffer
       memory, so that it cannot be changed or moved.
     </para>

     <para>
       The last structure is fb_monospecs. In the old API, there was 
       little importance for fb_monospecs. This allowed for forbidden things 
       such as setting a mode of 800x600 on a fix frequency monitor. With 
       the new API, fb_monospecs prevents such things, and if used 
       correctly, can prevent a monitor from being cooked.  fb_monospecs
       will not be useful until kernels 2.5.x.
     </para>

     <sect1><title>Frame Buffer Memory</title>
<!-- drivers/video/fbmem.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-register-framebuffer">register_framebuffer</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>register_framebuffer</refname>
 <refpurpose>
   registers a frame buffer device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_framebuffer </function></funcdef>
   <paramdef>struct fb_info * <parameter>fb_info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb_info</parameter></term>
   <listitem>
    <para>
      frame buffer info structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Registers a frame buffer device <parameter>fb_info</parameter>.
   </para><para>

   Returns negative errno on error, or zero for success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-unregister-framebuffer">unregister_framebuffer</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>unregister_framebuffer</refname>
 <refpurpose>
      releases a frame buffer device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>unregister_framebuffer </function></funcdef>
   <paramdef>struct fb_info * <parameter>fb_info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb_info</parameter></term>
   <listitem>
    <para>
      frame buffer info structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Unregisters a frame buffer device <parameter>fb_info</parameter>.
   </para><para>

   Returns negative errno on error, or zero for success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-register-client">fb_register_client</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_register_client</refname>
 <refpurpose>
      register a client notifier
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_register_client </function></funcdef>
   <paramdef>struct notifier_block * <parameter>nb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nb</parameter></term>
   <listitem>
    <para>
      notifier block to callback on events
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-unregister-client">fb_unregister_client</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_unregister_client</refname>
 <refpurpose>
      unregister a client notifier
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_unregister_client </function></funcdef>
   <paramdef>struct notifier_block * <parameter>nb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nb</parameter></term>
   <listitem>
    <para>
      notifier block to callback on events
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-set-suspend">fb_set_suspend</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_set_suspend</refname>
 <refpurpose>
      low level driver signals suspend
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_set_suspend </function></funcdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
   <paramdef>int <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
      framebuffer affected
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
      0 = resuming, !=0 = suspending
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This is meant to be used by low level drivers to
   signal suspend/resume to the core &amp; clients.
   It must be called with the console semaphore held
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-get-options">fb_get_options</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_get_options</refname>
 <refpurpose>
      get kernel boot parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_get_options </function></funcdef>
   <paramdef>char * <parameter>name</parameter></paramdef>
   <paramdef>char ** <parameter>option</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>option</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <parameter>name</parameter> - framebuffer name as it would appear in
   the boot parameter line
   (video=&lt;name&gt;:&lt;options&gt;)
 </para>
</refsect1>
<refsect1>
 <title>NOTE</title>
 <para>
    Needed to maintain backwards compatibility
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Frame Buffer Console</title>
<!-- drivers/video/console/fbcon.c -->
<refentry>
 <refnamediv>
  <refname>
   /home/liuhaozzu/repoes/linux/kernels/linux-2.6.11/drivers/video/console/fbcon.c
  </refname>
  <refpurpose>
   Document generation inconsistency
  </refpurpose>
 </refnamediv>
 <refsect1>
  <title>
   Oops
  </title>
  <warning>
   <para>
    The template for this document tried to insert
    the structured comment from the file
    <filename>/home/liuhaozzu/repoes/linux/kernels/linux-2.6.11/drivers/video/console/fbcon.c</filename> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </para>
  </warning>
 </refsect1>
</refentry>
     </sect1>
     <sect1><title>Frame Buffer Colormap</title>
<!-- drivers/video/fbcmap.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-alloc-cmap">fb_alloc_cmap</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_alloc_cmap</refname>
 <refpurpose>
   allocate a colormap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_alloc_cmap </function></funcdef>
   <paramdef>struct fb_cmap * <parameter>cmap</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
   <paramdef>int <parameter>transp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmap</parameter></term>
   <listitem>
    <para>
      frame buffer colormap structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
      length of <parameter>cmap</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>transp</parameter></term>
   <listitem>
    <para>
      boolean, 1 if there is transparency, 0 otherwise
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Allocates memory for a colormap <parameter>cmap</parameter>.  <parameter>len</parameter> is the
   number of entries in the palette.
   </para><para>

   Returns -1 errno on error, or zero on success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-dealloc-cmap">fb_dealloc_cmap</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_dealloc_cmap</refname>
 <refpurpose>
      deallocate a colormap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_dealloc_cmap </function></funcdef>
   <paramdef>struct fb_cmap * <parameter>cmap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmap</parameter></term>
   <listitem>
    <para>
      frame buffer colormap structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Deallocates a colormap that was previously allocated with
   <function>fb_alloc_cmap</function>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-copy-cmap">fb_copy_cmap</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_copy_cmap</refname>
 <refpurpose>
      copy a colormap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_copy_cmap </function></funcdef>
   <paramdef>struct fb_cmap * <parameter>from</parameter></paramdef>
   <paramdef>struct fb_cmap * <parameter>to</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
      frame buffer colormap structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
      frame buffer colormap structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Copy contents of colormap from <parameter>from</parameter> to <parameter>to</parameter>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-set-cmap">fb_set_cmap</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_set_cmap</refname>
 <refpurpose>
      set the colormap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_set_cmap </function></funcdef>
   <paramdef>struct fb_cmap * <parameter>cmap</parameter></paramdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmap</parameter></term>
   <listitem>
    <para>
      frame buffer colormap structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
      frame buffer info structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Sets the colormap <parameter>cmap</parameter> for a screen of device <parameter>info</parameter>.
   </para><para>

   Returns negative errno on error, or zero on success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-default-cmap">fb_default_cmap</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_default_cmap</refname>
 <refpurpose>
      get default colormap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct fb_cmap * <function>fb_default_cmap </function></funcdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
      size of palette for a depth
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Gets the default colormap for a specific screen depth.  <parameter>len</parameter>
   is the size of the palette for a particular screen depth.
   </para><para>

   Returns pointer to a frame buffer colormap structure.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-invert-cmaps">fb_invert_cmaps</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_invert_cmaps</refname>
 <refpurpose>
      invert all defaults colormaps
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_invert_cmaps </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   Invert all default colormaps.
 </para>
</refsect1>
</refentry>

     </sect1>
<!-- FIXME:
  drivers/video/fbgen.c has no docs, which stuffs up the sgml.  Comment
  out until somebody adds docs.  KAO
     <sect1><title>Frame Buffer Generic Functions</title>
X!Idrivers/video/fbgen.c
     </sect1>
KAO -->
     <sect1><title>Frame Buffer Video Mode Database</title>
<!-- drivers/video/modedb.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-try-mode">fb_try_mode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_try_mode</refname>
 <refpurpose>
   test a video mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_try_mode </function></funcdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
   <paramdef>const struct fb_videomode * <parameter>mode</parameter></paramdef>
   <paramdef>unsigned int <parameter>bpp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
      frame buffer user defined part of display
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
      frame buffer info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      frame buffer video mode structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bpp</parameter></term>
   <listitem>
    <para>
      color depth in bits per pixel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Tries a video mode to test it's validity for device <parameter>info</parameter>.
   </para><para>

   Returns 1 on success.
 </para>
</refsect1>
</refentry>

<!-- drivers/video/modedb.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-find-mode">fb_find_mode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_find_mode</refname>
 <refpurpose>
   finds a valid video mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_find_mode </function></funcdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
   <paramdef>const char * <parameter>mode_option</parameter></paramdef>
   <paramdef>const struct fb_videomode * <parameter>db</parameter></paramdef>
   <paramdef>unsigned int <parameter>dbsize</parameter></paramdef>
   <paramdef>const struct fb_videomode * <parameter>default_mode</parameter></paramdef>
   <paramdef>unsigned int <parameter>default_bpp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
      frame buffer user defined part of display
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
      frame buffer info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode_option</parameter></term>
   <listitem>
    <para>
      string video mode to find
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>db</parameter></term>
   <listitem>
    <para>
      video mode database
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dbsize</parameter></term>
   <listitem>
    <para>
      size of <parameter>db</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>default_mode</parameter></term>
   <listitem>
    <para>
      default video mode to fall back to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>default_bpp</parameter></term>
   <listitem>
    <para>
      default color depth in bits per pixel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Finds a suitable video mode, starting with the specified mode
   in <parameter>mode_option</parameter> with fallback to <parameter>default_mode</parameter>.  If
   <parameter>default_mode</parameter> fails, all modes in the video mode database will
   be tried.
   </para><para>

   Valid mode specifiers for <parameter>mode_option</parameter>:
   </para><para>

   &lt;xres&gt;x&lt;yres&gt;[-&lt;bpp&gt;][@&lt;refresh&gt;] or
   &lt;name&gt;[-&lt;bpp&gt;][@&lt;refresh&gt;]
   </para><para>

   with &lt;xres&gt;, &lt;yres&gt;, &lt;bpp&gt; and &lt;refresh&gt; decimal numbers and
   &lt;name&gt; a string.
 </para>
</refsect1>
<refsect1>
 <title>NOTE</title>
 <para>
    The passed struct <parameter>var</parameter> is _not_ cleared!  This allows you
   to supply values for e.g. the grayscale and accel_flags fields.
   </para><para>

   Returns zero for failure, 1 if using specified <parameter>mode_option</parameter>,
   2 if using specified <parameter>mode_option</parameter> with an ignored refresh rate,
   3 if default mode is used, 4 if fall back to any valid mode.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-var-to-videomode">fb_var_to_videomode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_var_to_videomode</refname>
 <refpurpose>
      convert fb_var_screeninfo to fb_videomode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_var_to_videomode </function></funcdef>
   <paramdef>struct fb_videomode * <parameter>mode</parameter></paramdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      pointer to struct fb_videomode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
      pointer to struct fb_var_screeninfo
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-videomode-to-var">fb_videomode_to_var</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_videomode_to_var</refname>
 <refpurpose>
      convert fb_videomode to fb_var_screeninfo
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_videomode_to_var </function></funcdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct fb_videomode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
      pointer to struct fb_var_screeninfo
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      pointer to struct fb_videomode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-mode-is-equal">fb_mode_is_equal</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_mode_is_equal</refname>
 <refpurpose>
      compare 2 videomodes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_mode_is_equal </function></funcdef>
   <paramdef>struct fb_videomode * <parameter>mode1</parameter></paramdef>
   <paramdef>struct fb_videomode * <parameter>mode2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode1</parameter></term>
   <listitem>
    <para>
      first videomode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode2</parameter></term>
   <listitem>
    <para>
      second videomode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>RETURNS</title>
 <para>
   1 if equal, 0 if not
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-find-best-mode">fb_find_best_mode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_find_best_mode</refname>
 <refpurpose>
      find best matching videomode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct fb_videomode * <function>fb_find_best_mode </function></funcdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
      pointer to struct fb_var_screeninfo
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      pointer to struct list_head of modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>RETURNS</title>
 <para>
   struct fb_videomode, NULL if none found
 </para>
</refsect1>
<refsect1>
 <title>IMPORTANT</title>
 <para>
   This function assumes that all modelist entries in
   info-&gt;modelist are valid.
 </para>
</refsect1>
<refsect1>
 <title>NOTES</title>
 <para>
   Finds best matching videomode which has an equal or greater dimension than
   var-&gt;xres and var-&gt;yres.  If more than 1 videomode is found, will return
   the videomode with the highest refresh rate
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-match-mode">fb_match_mode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_match_mode</refname>
 <refpurpose>
      find a videomode which exactly matches the timings in var
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct fb_videomode * <function>fb_match_mode </function></funcdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
      pointer to struct fb_var_screeninfo
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      pointer to struct list_head of modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>RETURNS</title>
 <para>
   struct fb_videomode, NULL if none found
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-add-videomode">fb_add_videomode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_add_videomode</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_add_videomode </function></funcdef>
   <paramdef>struct fb_videomode * <parameter>mode</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      videomode to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      struct list_head of modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>NOTES</title>
 <para>
   Will only add unmatched mode entries
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-delete-videomode">fb_delete_videomode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_delete_videomode</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_delete_videomode </function></funcdef>
   <paramdef>struct fb_videomode * <parameter>mode</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      videomode to remove
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      struct list_head of modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>NOTES</title>
 <para>
   Will remove all matching mode entries
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-destroy-modelist">fb_destroy_modelist</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_destroy_modelist</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_destroy_modelist </function></funcdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      struct list_head of modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-fb-videomode-to-modelist">fb_videomode_to_modelist</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>fb_videomode_to_modelist</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_videomode_to_modelist </function></funcdef>
   <paramdef>struct fb_videomode * <parameter>modedb</parameter></paramdef>
   <paramdef>int <parameter>num</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>modedb</parameter></term>
   <listitem>
    <para>
      array of struct fb_videomode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
      number of entries in array
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
      struct list_head of modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Frame Buffer Macintosh Video Mode Database</title>
<!-- drivers/video/macmodes.c -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-mac-vmode-to-var">mac_vmode_to_var</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mac_vmode_to_var</refname>
 <refpurpose>
   converts vmode/cmode pair to var structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mac_vmode_to_var </function></funcdef>
   <paramdef>int <parameter>vmode</parameter></paramdef>
   <paramdef>int <parameter>cmode</parameter></paramdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vmode</parameter></term>
   <listitem>
    <para>
      MacOS video mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmode</parameter></term>
   <listitem>
    <para>
      MacOS color mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
      frame buffer video mode structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Converts a MacOS vmode/cmode pair to a frame buffer video
   mode structure.
   </para><para>

   Returns negative errno on error, or zero for success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mac-var-to-vmode">mac_var_to_vmode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mac_var_to_vmode</refname>
 <refpurpose>
      convert var structure to MacOS vmode/cmode pair
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mac_var_to_vmode </function></funcdef>
   <paramdef>const struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>int * <parameter>vmode</parameter></paramdef>
   <paramdef>int * <parameter>cmode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
      frame buffer video mode structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vmode</parameter></term>
   <listitem>
    <para>
      MacOS video mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmode</parameter></term>
   <listitem>
    <para>
      MacOS color mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Converts a frame buffer video mode structure to a MacOS
   vmode/cmode pair.
   </para><para>

   Returns negative errno on error, or zero for success.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mac-map-monitor-sense">mac_map_monitor_sense</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mac_map_monitor_sense</refname>
 <refpurpose>
      Convert monitor sense to vmode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mac_map_monitor_sense </function></funcdef>
   <paramdef>int <parameter>sense</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sense</parameter></term>
   <listitem>
    <para>
      Macintosh monitor sense number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Converts a Macintosh monitor sense number to a MacOS
   vmode number.
   </para><para>

   Returns MacOS vmode video mode number.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-mac-find-mode">mac_find_mode</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>mac_find_mode</refname>
 <refpurpose>
      find a video mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int __init <function>mac_find_mode </function></funcdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
   <paramdef>const char * <parameter>mode_option</parameter></paramdef>
   <paramdef>unsigned int <parameter>default_bpp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
      frame buffer user defined part of display
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
      frame buffer info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode_option</parameter></term>
   <listitem>
    <para>
      video mode name (see mac_modedb[])
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>default_bpp</parameter></term>
   <listitem>
    <para>
      default color depth in bits per pixel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Finds a suitable video mode.  Tries to set mode specified
   by <parameter>mode_option</parameter>.  If the name of the wanted mode begins with
   'mac', the Mac video mode database will be used, otherwise it
   will fall back to the standard video mode database.
 </para>
</refsect1>
<refsect1>
 <title>Note</title>
 <para>
    Function marked as __init and can only be used during
   system boot.
   </para><para>

   Returns error code from fb_find_mode (see fb_find_mode
   function).
 </para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Frame Buffer Fonts</title>
        <para>
           Refer to the file drivers/video/console/fonts.c for more information.
        </para>
<!-- FIXME: Removed for now since no structured comments in source
X!Idrivers/video/console/fonts.c
-->
     </sect1>
  </chapter>
</book>
