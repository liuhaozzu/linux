<!-- -*- sgml -*- -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN"[]>

<book id="scsidrivers">
 <bookinfo>
  <title>SCSI Subsystem Interfaces</title>
  
  <authorgroup>
   <author>
    <firstname>Douglas</firstname>
    <surname>Gilbert</surname>
    <affiliation>
     <address>
      <email>dgilbert@interlog.com</email>
     </address>
    </affiliation>
   </author>
  </authorgroup>
  <pubdate>2003-08-11</pubdate>

  <copyright>
   <year>2002</year>
   <year>2003</year>
   <holder>Douglas Gilbert</holder>
  </copyright>

  <legalnotice>
   <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
      
   <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
      
   <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
      
   <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
  </legalnotice>

 </bookinfo>

<toc></toc>

  <chapter id="intro">
      <title>Introduction</title>
  <para>
This document outlines the interface between the Linux scsi mid level
and lower level drivers. Lower level drivers are variously called HBA
(host bus adapter) drivers, host drivers (HD) or pseudo adapter drivers.
The latter alludes to the fact that a lower level driver may be a
bridge to another IO subsystem (and the "ide-scsi" driver is an example
of this). There can be many lower level drivers active in a running
system, but only one per hardware type. For example, the aic7xxx driver
controls adaptec controllers based on the 7xxx chip series. Most lower
level drivers can control one or more scsi hosts (a.k.a. scsi initiators).
  </para>
<para>
This document can been found in an ASCII text file in the linux kernel 
source: <filename>Documentation/scsi/scsi_mid_low_api.txt</filename> .
It currently hold a little more information than this document. The
<filename>drivers/scsi/hosts.h</filename> and <filename>
drivers/scsi/scsi.h</filename> headers contain descriptions of members
of important structures for the scsi subsystem.
</para>
  </chapter>

  <chapter id="driver-struct">
      <title>Driver structure</title>
  <para>
Traditionally a lower level driver for the scsi subsystem has been
at least two files in the drivers/scsi directory. For example, a
driver called "xyz" has a header file "xyz.h" and a source file
"xyz.c". [Actually there is no good reason why this couldn't all
be in one file.] Some drivers that have been ported to several operating
systems (e.g. aic7xxx which has separate  files for generic and
OS-specific code) have more than two files. Such drivers tend to have
their own directory under the drivers/scsi directory.
  </para>
  <para>
scsi_module.c is normally included at the end of a lower
level driver. For it to work a declaration like this is needed before
it is included:
<programlisting>
    static Scsi_Host_Template driver_template = DRIVER_TEMPLATE;
    /* DRIVER_TEMPLATE should contain pointers to supported interface
       functions. Scsi_Host_Template is defined hosts.h */
    #include "scsi_module.c"
</programlisting>
  </para>
  <para>
The scsi_module.c assumes the name "driver_template" is appropriately
defined. It contains 2 functions:
<orderedlist>
<listitem><para>
     init_this_scsi_driver() called during builtin and module driver
     initialization: invokes mid level's scsi_register_host()
</para></listitem>
<listitem><para>
     exit_this_scsi_driver() called during closedown: invokes
     mid level's scsi_unregister_host()
</para></listitem>
</orderedlist>
  </para>
<para>
When a new, lower level driver is being added to Linux, the following 
files (all found in the drivers/scsi directory) will need some attention: 
Makefile, Config.help and Config.in . It is probably best to look at what 
an existing lower level driver does in this regard.
</para>
  </chapter>

  <chapter id="intfunctions">
     <title>Interface Functions</title>
<!-- Documentation/scsi/scsi_mid_low_api.txt -->
<refentry>
<refmeta>
<refentrytitle><phrase id="API-scsi-activate-tcq">scsi_activate_tcq</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>scsi_activate_tcq</refname>
 <refpurpose>
   turn on tag command queueing (<quote>ordered</quote> task attribute)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_activate_tcq </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>int <parameter>depth</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
            device to turn on TCQ for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>depth</parameter></term>
   <listitem>
    <para>
           queue depth
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns nothing
 </para>
</refsect1>
<refsect1>
 <title>Might block</title>
 <para>
    no
 </para>
</refsect1>
<refsect1>
 <title>Notes</title>
 <para>
    Eventually, it is hoped depth would be the maximum depth
   the device could cope with and the real queue depth
   would be adjustable from 0 to depth.
   </para><para>

   Defined (inline) in: include/scsi/scsi_tcq.h
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-scsi-unblock-requests">scsi_unblock_requests</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>scsi_unblock_requests</refname>
 <refpurpose>
      allow further commands to be queued to given host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>scsi_unblock_requests </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>shost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>shost</parameter></term>
   <listitem>
    <para>
      pointer to host to unblock commands on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns nothing
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns nothing
 </para>
</refsect1>
<refsect1>
 <title>Might block</title>
 <para>
    no
 </para>
</refsect1>
<refsect1>
 <title>Defined in</title>
 <para>
    drivers/scsi/scsi_lib.c .
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-bios-param">bios_param</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>bios_param</refname>
 <refpurpose>
      fetch head, sector, cylinder info for a disk
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>bios_param </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>struct block_device * <parameter>bdev</parameter></paramdef>
   <paramdef>sector_t <parameter>capacity</parameter></paramdef>
   <paramdef>int <parameter>params[3]</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
      pointer to scsi device context (defined in 
     include/scsi/scsi_device.h)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bdev</parameter></term>
   <listitem>
    <para>
      pointer to block device context (defined in fs.h)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>capacity</parameter></term>
   <listitem>
    <para>
       device size (in 512 byte sectors)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>params[3]</parameter></term>
   <listitem>
    <para>
      three element array to place output:
     params[0] number of heads (max 255)
     params[1] number of sectors (max 63)
     params[2] number of cylinders 
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Return value is ignored
 </para>
</refsect1>
<refsect1>
 <title>Locks</title>
 <para>
    none
 </para>
</refsect1>
<refsect1>
 <title>Calling context</title>
 <para>
    process (sd)
 </para>
</refsect1>
<refsect1>
 <title>Notes</title>
 <para>
    an arbitrary geometry (based on READ CAPACITY) is used
   if this function is not provided. The params array is
   pre-initialized with made up values just in case this function 
   doesn't output anything.
 </para>
</refsect1>
<refsect1>
 <title>Optionally defined in</title>
 <para>
    LLD
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-queuecommand">queuecommand</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>queuecommand</refname>
 <refpurpose>
      queue scsi command, invoke 'done' on completion
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>queuecommand </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>scp</parameter></paramdef>
   <paramdef>void (*<parameter>done</parameter>)
     <funcparams>struct scsi_cmnd *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>scp</parameter></term>
   <listitem>
    <para>
      pointer to scsi command object
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>done</parameter></term>
   <listitem>
    <para>
      function pointer to be invoked on completion
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns 0 on success.
   </para><para>

   If there's a failure, return either:
   </para><para>

   SCSI_MLQUEUE_DEVICE_BUSY if the device queue is full, or
   SCSI_MLQUEUE_HOST_BUSY if the entire host queue is full
   </para><para>

   On both of these returns, the mid-layer will requeue the I/O
   </para><para>

   - if the return is SCSI_MLQUEUE_DEVICE_BUSY, only that particular
   device will be paused, and it will be unpaused when a command to
   the device returns (or after a brief delay if there are no more
   outstanding commands to it).  Commands to other devices continue
   to be processed normally.
   </para><para>

   - if the return is SCSI_MLQUEUE_HOST_BUSY, all I/O to the host
   is paused and will be unpaused when any command returns from
   the host (or after a brief delay if there are no outstanding
   commands to the host).
   </para><para>

   For compatibility with earlier versions of queuecommand, any
   other return value is treated the same as
   SCSI_MLQUEUE_HOST_BUSY.
   </para><para>

   Other types of errors that are detected immediately may be
   flagged by setting scp-&gt;result to an appropriate value,
   invoking the 'done' callback, and then returning 0 from this
   function. If the command is not performed immediately (and the
   LLD is starting (or will start) the given command) then this
   function should place 0 in scp-&gt;result and return 0.
   </para><para>

   Command ownership.  If the driver returns zero, it owns the
   command and must take responsibility for ensuring the 'done'
   callback is executed.  Note: the driver may call done before
   returning zero, but after it has called done, it may not
   return any value other than zero.  If the driver makes a
   non-zero return, it must not execute the command's done
   callback at any time.
 </para>
</refsect1>
<refsect1>
 <title>Locks</title>
 <para>
    struct Scsi_Host::host_lock held on entry (with <quote>irqsave</quote>)
   and is expected to be held on return.
 </para>
</refsect1>
<refsect1>
 <title>Calling context</title>
 <para>
    in interrupt (soft irq) or process context
 </para>
</refsect1>
<refsect1>
 <title>Notes</title>
 <para>
    This function should be relatively fast. Normally it will
   not wait for IO to complete. Hence the 'done' callback is invoked 
   (often directly from an interrupt service routine) some time after
   this function has returned. In some cases (e.g. pseudo adapter 
   drivers that manufacture the response to a SCSI INQUIRY)
   the 'done' callback may be invoked before this function returns.
   If the 'done' callback is not invoked within a certain period
   the SCSI mid level will commence error processing.
   If a status of CHECK CONDITION is placed in <quote>result</quote> when the
   'done' callback is invoked, then the LLD driver should 
 </para>
</refsect1>
<refsect1>
 <title>perform autosense and fill in the struct scsi_cmnd</title>
 <para>
   :sense_buffer
   array. The scsi_cmnd::sense_buffer array is zeroed prior to
   the mid level queuing a command to an LLD.
 </para>
</refsect1>
<refsect1>
 <title>Defined in</title>
 <para>
    LLD
 </para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="locks">
     <title>Locks</title>
<para>
Each Scsi_Host instance has a spin_lock called Scsi_Host::default_lock
which is initialized in scsi_register() [found in hosts.c]. Within the
same function the Scsi_Host::host_lock pointer is initialized to point
at default_lock with the scsi_assign_lock() function. Thereafter
lock and unlock operations performed by the mid level use the
Scsi_Host::host_lock pointer.
</para>
<para>
Lower level drivers can override the use of Scsi_Host::default_lock by
using scsi_assign_lock(). The earliest opportunity to do this would
be in the detect() function after it has invoked scsi_register(). It
could be replaced by a coarser grain lock (e.g. per driver) or a
lock of equal granularity (i.e. per host). Using finer grain locks
(e.g. per scsi device) may be possible by juggling locks in
queuecommand().
</para>
  </chapter>

  <chapter id="changes">
     <title>Changes since lk 2.4 series</title>
<para>
io_request_lock has been replaced by several finer grained locks. The lock
relevant to lower level drivers is Scsi_Host::host_lock and there is one
per scsi host.
</para>
<para>
The older error handling mechanism has been removed. This means the
lower level interface functions abort() and reset() have been removed.
</para>
<para>
In the 2.4 series the scsi subsystem configuration descriptions were
aggregated with the configuration descriptions from all other Linux
subsystems in the Documentation/Configure.help file. In the 2.5 series,
the scsi subsystem now has its own (much smaller) drivers/scsi/Config.help
file.
</para>
  </chapter>

  <chapter id="credits">
     <title>Credits</title>
<para>
The following people have contributed to this document:
<orderedlist>
<listitem><para>
Mike Anderson <email>andmike@us.ibm.com</email>
</para></listitem>
<listitem><para>
James Bottomley <email>James.Bottomley@steeleye.com</email>
</para></listitem>
<listitem><para>
Patrick Mansfield <email>patmans@us.ibm.com</email>
</para></listitem>
</orderedlist>
</para>
  </chapter>

</book>
